--[[
    Скрипт ключ-системы AHK v2.24
]]
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")

if _G.AHKKeySys_Cleanup and typeof(_G.AHKKeySys_Cleanup) == "function" then
    local oldCleanup = _G.AHKKeySys_Cleanup; _G.AHKKeySys_Cleanup = nil; pcall(oldCleanup); task.wait(0.1)
end

if not (writefile and readfile and isfile and HttpService and game.HttpGet) then
    warn("AHK KeySys CRITICAL: Отсутствуют HttpGet или файловые функции эксплойта. Скрипт не может продолжить работу.")
    return
end

local TARGET_PLACE_ID = 10449761463
local localActivationFileName = "truekey.json"
local FIREBASE_DB_URL = "https://sync-10d69-default-rtdb.europe-west1.firebasedatabase.app"
local SCRIPT_FOR_PC = "https://pastebin.com/raw/88Rzg85r"
local SCRIPT_FOR_MOBILE = "https://pastebin.com/raw/nTu3BbJM"

local colors = { background = Color3.fromRGB(30, 30, 35), surface = Color3.fromRGB(45, 45, 50), primary = Color3.fromRGB(60, 180, 160), secondary = Color3.fromRGB(80, 80, 90), text = Color3.fromRGB(230, 230, 230), text_secondary = Color3.fromRGB(160, 160, 170), outline = Color3.fromRGB(70, 70, 75), shadow = Color3.fromRGB(0, 0, 0), success = Color3.fromRGB(70, 200, 100), error = Color3.fromRGB(220, 80, 80) }
local shadowTransparency = 0.7; local shadowOffset = Vector2.new(3, 3); local outlineThickness = 1; local cornerRadiusLarge = 12; local cornerRadiusMedium = 8

local player = Players.LocalPlayer
local screenGui, mainFrame, mainFrameShadow, titleLabel, keyTextBox, getKeyButton, checkKeyButton, statusLabel, getKeyInfoFrame, getKeyInfoFrameShadow, getKeyInfoLabel, getKeyInfoStroke, blurEffect = nil
local confirmationScreenGui = nil
local initialCFrame = nil
local isGetKeyInfoAnimating = false; local isGetKeyInfoVisible = false; local currentGetKeyInfoTween = nil
local alreadyLocallyActivated = false
local actionsToBlock = { Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D, Enum.KeyCode.Space, Enum.KeyCode.One, Enum.KeyCode.Two, Enum.KeyCode.Three, Enum.KeyCode.Four, Enum.KeyCode.Q, Enum.KeyCode.E }
local mainLogicCoroutine = nil
local connectionPlayerRemoving = nil

local function getLocalActivationData() local success, result = pcall(function() if isfile and isfile(localActivationFileName) and readfile then local content = readfile(localActivationFileName); if content and content ~= "" then local decodeSuccess, data = pcall(HttpService.JSONDecode, HttpService, content); if decodeSuccess and typeof(data) == "table" and data.locally_activated_key then return data end end end; return nil end); if not success then return nil end; return result end
local function markAsLocallyActivated(activatedKey) local success, result = pcall(function() if writefile then local timestampValue = os.time(); if timestampValue == nil then timestampValue = math.floor(tick()) end; local escapedKey = string.gsub(tostring(activatedKey or ""), "\"", "\\\""); local numericTimestamp = tonumber(timestampValue) or 0; local jsonString = string.format('{"locally_activated_key":"%s","local_activation_time":%d}', escapedKey, numericTimestamp); if jsonString then writefile(localActivationFileName, jsonString) else error("JSON gen failed.") end else error("writefile missing.") end; return true end); if not success then return false, result end; return true end
local function clearLocalActivation() pcall(function() if writefile then writefile(localActivationFileName, "") end end) end

alreadyLocallyActivated = getLocalActivationData()

local function validateKeyFormat(key) local digitCount = 0; local letterCount = 0; local letters = {}; local targetSortedLetters = "abghks"; if not key or key == "" then return false end; for char in key:gmatch(".") do if char:match("%d") then digitCount = digitCount + 1 elseif char:match("%a") then letterCount = letterCount + 1; table.insert(letters, char:lower()) end end; if digitCount < 16 then return false end; if letterCount ~= 6 then return false end; table.sort(letters); if table.concat(letters) ~= targetSortedLetters then return false end; return true end
local function cleanupCurrentInstance(teleportBack) teleportBack = teleportBack == nil and true or teleportBack; for i, _ in ipairs(actionsToBlock) do ContextActionService:UnbindAction("AHK_BlockInput_" .. i) end; local currentCharacter = player.Character; if currentCharacter then local currentHumanoid = currentCharacter:FindFirstChildOfClass("Humanoid"); if currentHumanoid then currentHumanoid.WalkSpeed = 16; currentHumanoid.JumpPower = 50 end end; local allDisappearTweens = {}; local tweenInfoUIDisappear = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In); if mainFrame and mainFrame.Parent then table.insert(allDisappearTweens, TweenService:Create(mainFrame, tweenInfoUIDisappear, {BackgroundTransparency = 1})) end; if mainFrameShadow and mainFrameShadow.Parent then table.insert(allDisappearTweens, TweenService:Create(mainFrameShadow, tweenInfoUIDisappear, {BackgroundTransparency = 1})) end; if mainFrame and mainFrame:FindFirstChildOfClass("UIStroke") then table.insert(allDisappearTweens, TweenService:Create(mainFrame:FindFirstChildOfClass("UIStroke"), tweenInfoUIDisappear, {Transparency = 1})) end; local childrenToFadeOut = { titleLabel, keyTextBox, getKeyButton, checkKeyButton, statusLabel }; for _, child in ipairs(childrenToFadeOut) do if child and child.Parent then local props = {}; local stroke = child:FindFirstChildOfClass("UIStroke"); if child.TextTransparency < 1 then props.TextTransparency = 1 end; if child ~= titleLabel and child ~= statusLabel and child.BackgroundTransparency < 1 then props.BackgroundTransparency = 1 end; if next(props) then table.insert(allDisappearTweens, TweenService:Create(child, tweenInfoUIDisappear, props)) end; if stroke and stroke.Transparency < 1 then table.insert(allDisappearTweens, TweenService:Create(stroke, tweenInfoUIDisappear, {Transparency = 1})) end end end; for _, tween in ipairs(allDisappearTweens) do tween:Play() end; if allDisappearTweens[1] then allDisappearTweens[1].Completed:Wait() else task.wait(tweenInfoUIDisappear.Time) end; if blurEffect and blurEffect.Parent then local tweenInfoBlurDisappear = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In); local tweenBlurDisappear = TweenService:Create(blurEffect, tweenInfoBlurDisappear, {Size = 0}); tweenBlurDisappear:Play(); tweenBlurDisappear.Completed:Wait() end; if teleportBack then local currentCharacter = player.Character; if currentCharacter then local currentRootPart = currentCharacter:FindFirstChild("HumanoidRootPart"); if currentRootPart and initialCFrame then currentRootPart.CFrame = initialCFrame end end end; if screenGui and screenGui.Parent then screenGui:Destroy(); screenGui = nil end; if confirmationScreenGui and confirmationScreenGui.Parent then confirmationScreenGui:Destroy(); confirmationScreenGui = nil end; if blurEffect and blurEffect.Parent then blurEffect:Destroy(); blurEffect = nil end; if connectionPlayerRemoving then connectionPlayerRemoving:Disconnect(); connectionPlayerRemoving = nil end; if mainLogicCoroutine and coroutine.status(mainLogicCoroutine) ~= "dead" then coroutine.close(mainLogicCoroutine) end; _G.AHKKeySys_Cleanup = nil; end
local function animateGetKeyInfo(show) if not getKeyInfoFrame or not getKeyInfoFrameShadow or not getKeyInfoStroke or not getKeyInfoLabel then return end; if isGetKeyInfoAnimating then if currentGetKeyInfoTween then currentGetKeyInfoTween:Cancel() end end; isGetKeyInfoAnimating = true; isGetKeyInfoVisible = show; local tweenInfoGetKey = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out); local allKeyInfoTweens = {}; local targetTransparency = show and 0 or 1; local targetShadowTransparency = show and shadowTransparency or 1; local targetStrokeTransparency = show and 0 or 1; table.insert(allKeyInfoTweens, TweenService:Create(getKeyInfoFrame, tweenInfoGetKey, {BackgroundTransparency = targetTransparency})); table.insert(allKeyInfoTweens, TweenService:Create(getKeyInfoFrameShadow, tweenInfoGetKey, {BackgroundTransparency = targetShadowTransparency})); table.insert(allKeyInfoTweens, TweenService:Create(getKeyInfoStroke, tweenInfoGetKey, {Transparency = targetStrokeTransparency})); table.insert(allKeyInfoTweens, TweenService:Create(getKeyInfoLabel, tweenInfoGetKey, {TextTransparency = targetTransparency})); if show then getKeyInfoFrame.Visible = true; getKeyInfoFrameShadow.Visible = true end; for _, tween in ipairs(allKeyInfoTweens) do tween:Play() end; currentGetKeyInfoTween = allKeyInfoTweens[1]; currentGetKeyInfoTween.Completed:Connect(function(playbackState) if playbackState == Enum.PlaybackState.Completed then if not show then getKeyInfoFrame.Visible = false; getKeyInfoFrameShadow.Visible = false end end; isGetKeyInfoAnimating = false; currentGetKeyInfoTween = nil end) end
local function executeExternalScripts()
    local scriptUrlToLoad; local platformName
    if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then platformName = "Mobile"; scriptUrlToLoad = SCRIPT_FOR_MOBILE
    else platformName = "PC"; scriptUrlToLoad = SCRIPT_FOR_PC end
    if not scriptUrlToLoad or scriptUrlToLoad == "" then return end
    local success, scriptContent = pcall(game.HttpGet, game, scriptUrlToLoad, true)
    if success and scriptContent and scriptContent ~= "" then
        local compiledChunk, compileError = loadstring(scriptContent)
        if compiledChunk then local execSuccess, execError = pcall(compiledChunk)
            if not execSuccess then warn("AHK KeySys EXEC ERROR ("..platformName.."):", execError) end
        else warn("AHK KeySys COMPILE ERROR ("..platformName.."):", compileError) end
    else if not success then warn("AHK KeySys HTTPGET ERROR ("..platformName.."):", scriptContent) end
    end
end

local function checkKeyInFirebase(keyToCheck, callback)
    task.spawn(function()
        local isValid = false; local message = "Неизвестная ошибка."
        local generatedKeyUrl = FIREBASE_DB_URL .. "/generated_keys/" .. HttpService:UrlEncode(keyToCheck) .. ".json"
        local successGetGen, responseGen = pcall(function() return game:HttpGet(generatedKeyUrl, true) end)
        if successGetGen and responseGen and typeof(responseGen) == "string" then
            if responseGen == "null" then message = "Ключ не найден в базе."
            else
                local gen_status = string.match(responseGen, '"status"%s*:%s*"([^"]+)"')
                local gen_is_roblox_active = (string.match(responseGen, '"is_active_roblox"%s*:%s*(true)') == "true")
                if gen_status == "active" and not gen_is_roblox_active then
                    local usedKeyUrl = FIREBASE_DB_URL .. "/used_roblox_keys/" .. HttpService:UrlEncode(keyToCheck) .. ".json"
                    local successGetUsed, responseUsed = pcall(function() return game:HttpGet(usedKeyUrl, true) end)
                    if successGetUsed and responseUsed and typeof(responseUsed) == "string" then
                        if responseUsed == "null" then isValid = true; message = "Ключ верный! Загрузка..."
                        else local used_activated = (string.match(responseUsed, '"activated"%s*:%s*(true)') == "true"); if used_activated then message = "Ключ уже был активирован." else isValid = true; message = "Ключ верный! Загрузка... (st_used_!act)" end end
                    elseif not successGetUsed then message = "Ошибка Firebase (used_keys)."
                    else message = "Ответ Firebase (used_keys) не строка." end
                elseif gen_is_roblox_active then message = "Ключ уже активирован (gen_keys)."
                elseif gen_status == "expired" then message = "Срок действия ключа истек."
                else message = "Ключ неактивен/неверный статус." end
            end
        else message = "Ошибка Firebase (generated_keys)." end
        callback(isValid, message, keyToCheck)
    end)
end

local function initializeKeySystem()
    if confirmationScreenGui and confirmationScreenGui.Parent then confirmationScreenGui:Destroy(); confirmationScreenGui = nil end
    local localData = getLocalActivationData()
    if localData and localData.locally_activated_key then
        if not statusLabel and screenGui then statusLabel = Instance.new("TextLabel"); statusLabel.Name = "Status"; statusLabel.Size = UDim2.new(0.9, 0, 0, 20); statusLabel.Position = UDim2.new(0.5, 0, 0.88, 0); statusLabel.AnchorPoint = Vector2.new(0.5, 0); statusLabel.BackgroundTransparency = 1; statusLabel.Font = Enum.Font.Gotham; statusLabel.TextSize = 14; statusLabel.TextColor3 = colors.text; statusLabel.TextWrapped = true; statusLabel.Parent = mainFrame or screenGui end
        if statusLabel then statusLabel.TextColor3 = colors.text; statusLabel.Text = "Проверка пред. активации..."; statusLabel.TextTransparency = 0 end
        checkKeyInFirebase(localData.locally_activated_key, function(isStillValid, firebaseMessage, checkedKey)
            if isStillValid then task.spawn(executeExternalScripts); cleanupCurrentInstance(false); return
            else clearLocalActivation(); alreadyLocallyActivated = nil;
                if screenGui and screenGui.Parent and statusLabel then statusLabel.TextColor3 = colors.error; statusLabel.Text = firebaseMessage or "Пред. активация истекла."; statusLabel.TextTransparency = 0
                else initializeKeySystem() end
            end
        end); if not (screenGui and screenGui.Parent) and localData then return end
    end
    if alreadyLocallyActivated then return end
    local character = player.Character or player.CharacterAdded:Wait(); local humanoid = character:WaitForChild("Humanoid"); local rootPart = character:WaitForChild("HumanoidRootPart"); initialCFrame = rootPart.CFrame; local targetPosition = Vector3.new(1081, 20, 23090); rootPart.CFrame = CFrame.new(targetPosition); task.wait(0.1); local function sinkInputInternal() return Enum.ContextActionResult.Sink end; for i, keycode in ipairs(actionsToBlock) do ContextActionService:BindAction("AHK_BlockInput_" .. i, sinkInputInternal, false, keycode) end; humanoid.WalkSpeed = 0; humanoid.JumpPower = 0; screenGui = Instance.new("ScreenGui"); screenGui.Name = "AHKKeySysGui"; screenGui.ResetOnSpawn = false; screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; local mainFrameSize = UDim2.new(0, 350, 0, 200); local mainFramePos = UDim2.new(0.5, 0, 0.5, 0); mainFrameShadow = Instance.new("Frame"); mainFrameShadow.Name = "MainFrameShadow"; mainFrameShadow.Size = mainFrameSize + UDim2.new(0, shadowOffset.X, 0, shadowOffset.Y); mainFrameShadow.Position = mainFramePos + UDim2.new(0, shadowOffset.X / 2, 0, shadowOffset.Y / 2); mainFrameShadow.AnchorPoint = Vector2.new(0.5, 0.5); mainFrameShadow.BackgroundColor3 = colors.shadow; mainFrameShadow.BackgroundTransparency = 1; mainFrameShadow.BorderSizePixel = 0; mainFrameShadow.ZIndex = 1; mainFrameShadow.Parent = screenGui; local mainFrameShadowCorner = Instance.new("UICorner"); mainFrameShadowCorner.CornerRadius = UDim.new(0, cornerRadiusLarge); mainFrameShadowCorner.Parent = mainFrameShadow; mainFrame = Instance.new("Frame"); mainFrame.Name = "MainFrame"; mainFrame.Size = UDim2.new(0, 50, 0, 50); mainFrame.Position = UDim2.new(0.5, 0, 0.45, 0); mainFrame.AnchorPoint = Vector2.new(0.5, 0.5); mainFrame.BackgroundColor3 = colors.background; mainFrame.BackgroundTransparency = 1; mainFrame.BorderSizePixel = 0; mainFrame.ClipsDescendants = true; mainFrame.ZIndex = 2; mainFrame.Parent = screenGui; local mainFrameCorner = Instance.new("UICorner"); mainFrameCorner.CornerRadius = UDim.new(0, cornerRadiusLarge); mainFrameCorner.Parent = mainFrame; local mainFrameStroke = Instance.new("UIStroke"); mainFrameStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; mainFrameStroke.Color = colors.outline; mainFrameStroke.Thickness = outlineThickness; mainFrameStroke.Transparency = 1; mainFrameStroke.Parent = mainFrame; titleLabel = Instance.new("TextLabel"); titleLabel.Name = "Title"; titleLabel.Size = UDim2.new(1, 0, 0, 35); titleLabel.Position = UDim2.new(0, 0, 0, 0); titleLabel.BackgroundColor3 = colors.surface; titleLabel.BackgroundTransparency = 1; titleLabel.BorderSizePixel = 0; titleLabel.Text = "AHK keysys"; titleLabel.Font = Enum.Font.GothamSemibold; titleLabel.TextSize = 18; titleLabel.TextColor3 = colors.text; titleLabel.TextTransparency = 1; titleLabel.Parent = mainFrame; keyTextBox = Instance.new("TextBox"); keyTextBox.Name = "KeyInput"; keyTextBox.Size = UDim2.new(0.8, 0, 0, 35); keyTextBox.Position = UDim2.new(0.5, 0, 0.4, 0); keyTextBox.AnchorPoint = Vector2.new(0.5, 0.5); keyTextBox.BackgroundColor3 = colors.surface; keyTextBox.BackgroundTransparency = 1; keyTextBox.BorderSizePixel = 0; keyTextBox.Font = Enum.Font.Gotham; keyTextBox.TextSize = 16; keyTextBox.TextColor3 = colors.text; keyTextBox.TextTransparency = 1; keyTextBox.Text = ""; keyTextBox.PlaceholderText = "Enter key here..."; keyTextBox.PlaceholderColor3 = colors.text_secondary; keyTextBox.ClearTextOnFocus = true; keyTextBox.Parent = mainFrame; local keyTextBoxCorner = Instance.new("UICorner"); keyTextBoxCorner.CornerRadius = UDim.new(0, cornerRadiusMedium); keyTextBoxCorner.Parent = keyTextBox; local keyTextBoxStroke = Instance.new("UIStroke"); keyTextBoxStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; keyTextBoxStroke.Color = colors.outline; keyTextBoxStroke.Thickness = outlineThickness; keyTextBoxStroke.Transparency = 1; keyTextBoxStroke.Parent = keyTextBox; getKeyButton = Instance.new("TextButton"); getKeyButton.Name = "GetKey"; getKeyButton.Size = UDim2.new(0.4, 0, 0, 30); getKeyButton.Position = UDim2.new(0.28, 0, 0.7, 0); getKeyButton.AnchorPoint = Vector2.new(0.5, 0); getKeyButton.BackgroundColor3 = colors.secondary; getKeyButton.BackgroundTransparency = 1; getKeyButton.BorderSizePixel = 0; getKeyButton.Font = Enum.Font.GothamSemibold; getKeyButton.Text = "Get Key"; getKeyButton.TextSize = 15; getKeyButton.TextColor3 = colors.text; getKeyButton.TextTransparency = 1; getKeyButton.Parent = mainFrame; local getKeyCorner = Instance.new("UICorner"); getKeyCorner.CornerRadius = UDim.new(0, cornerRadiusMedium); getKeyCorner.Parent = getKeyButton; local getKeyStroke = Instance.new("UIStroke"); getKeyStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; getKeyStroke.Color = colors.outline; getKeyStroke.Thickness = outlineThickness; getKeyStroke.Transparency = 1; getKeyStroke.Parent = getKeyButton; checkKeyButton = Instance.new("TextButton"); checkKeyButton.Name = "CheckKey"; checkKeyButton.Size = UDim2.new(0.4, 0, 0, 30); checkKeyButton.Position = UDim2.new(0.72, 0, 0.7, 0); checkKeyButton.AnchorPoint = Vector2.new(0.5, 0); checkKeyButton.BackgroundColor3 = colors.primary; checkKeyButton.BackgroundTransparency = 1; checkKeyButton.BorderSizePixel = 0; checkKeyButton.Font = Enum.Font.GothamSemibold; checkKeyButton.Text = "Check Key"; checkKeyButton.TextSize = 15; checkKeyButton.TextColor3 = colors.background; checkKeyButton.TextTransparency = 1; checkKeyButton.Parent = mainFrame; local checkKeyCorner = Instance.new("UICorner"); checkKeyCorner.CornerRadius = UDim.new(0, cornerRadiusMedium); checkKeyCorner.Parent = checkKeyButton; local checkKeyStroke = Instance.new("UIStroke"); checkKeyStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; checkKeyStroke.Color = colors.outline; checkKeyStroke.Thickness = outlineThickness; checkKeyStroke.Transparency = 1; checkKeyStroke.Parent = checkKeyButton; statusLabel = Instance.new("TextLabel"); statusLabel.Name = "Status"; statusLabel.Size = UDim2.new(0.9, 0, 0, 20); statusLabel.Position = UDim2.new(0.5, 0, 0.88, 0); statusLabel.AnchorPoint = Vector2.new(0.5, 0); statusLabel.BackgroundTransparency = 1; statusLabel.Font = Enum.Font.Gotham; statusLabel.TextSize = 14; statusLabel.TextColor3 = colors.text; statusLabel.TextTransparency = 1; statusLabel.Text = ""; statusLabel.TextWrapped = true; statusLabel.Parent = mainFrame; local getKeyInfoWidth = 220; local getKeyInfoHeight = 80; local getKeyInfoSize = UDim2.new(0, getKeyInfoWidth, 0, getKeyInfoHeight); local getKeyInfoPos = UDim2.new(0.5, -(mainFrameSize.X.Offset / 2) - 10, 0.5, 0); getKeyInfoFrameShadow = Instance.new("Frame"); getKeyInfoFrameShadow.Name = "GetKeyInfoFrameShadow"; getKeyInfoFrameShadow.Size = getKeyInfoSize + UDim2.new(0, shadowOffset.X, 0, shadowOffset.Y); getKeyInfoFrameShadow.Position = getKeyInfoPos + UDim2.new(0, shadowOffset.X / 2, 0, shadowOffset.Y / 2); getKeyInfoFrameShadow.AnchorPoint = Vector2.new(1, 0.5); getKeyInfoFrameShadow.BackgroundColor3 = colors.shadow; getKeyInfoFrameShadow.BackgroundTransparency = 1; getKeyInfoFrameShadow.BorderSizePixel = 0; getKeyInfoFrameShadow.ZIndex = 3; getKeyInfoFrameShadow.Visible = false; getKeyInfoFrameShadow.Parent = screenGui; local getKeyInfoShadowCorner = Instance.new("UICorner"); getKeyInfoShadowCorner.CornerRadius = UDim.new(0, cornerRadiusMedium); getKeyInfoShadowCorner.Parent = getKeyInfoFrameShadow; getKeyInfoFrame = Instance.new("Frame"); getKeyInfoFrame.Name = "GetKeyInfoFrame"; getKeyInfoFrame.Size = getKeyInfoSize; getKeyInfoFrame.Position = getKeyInfoPos; getKeyInfoFrame.AnchorPoint = Vector2.new(1, 0.5); getKeyInfoFrame.BackgroundColor3 = colors.surface; getKeyInfoFrame.BackgroundTransparency = 1; getKeyInfoFrame.BorderSizePixel = 0; getKeyInfoFrame.Visible = false; getKeyInfoFrame.ClipsDescendants = true; getKeyInfoFrame.ZIndex = 4; getKeyInfoFrame.Parent = screenGui; local getKeyInfoCorner = Instance.new("UICorner"); getKeyInfoCorner.CornerRadius = UDim.new(0, cornerRadiusMedium); getKeyInfoCorner.Parent = getKeyInfoFrame; getKeyInfoStroke = Instance.new("UIStroke"); getKeyInfoStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; getKeyInfoStroke.Color = colors.outline; getKeyInfoStroke.Thickness = outlineThickness; getKeyInfoStroke.Transparency = 1; getKeyInfoStroke.Parent = getKeyInfoFrame; getKeyInfoLabel = Instance.new("TextLabel"); getKeyInfoLabel.Name = "InfoLabel"; getKeyInfoLabel.Size = UDim2.new(1, -20, 1, -10); getKeyInfoLabel.Position = UDim2.new(0.5, 0, 0.5, 0); getKeyInfoLabel.AnchorPoint = Vector2.new(0.5, 0.5); getKeyInfoLabel.BackgroundTransparency = 1; getKeyInfoLabel.Text = "получите ключ в телеграмм боте: @AHKkey_BOT"; getKeyInfoLabel.Font = Enum.Font.Gotham; getKeyInfoLabel.TextSize = 14; getKeyInfoLabel.TextColor3 = colors.text; getKeyInfoLabel.TextTransparency = 1; getKeyInfoLabel.TextWrapped = true; getKeyInfoLabel.Parent = getKeyInfoFrame;
    blurEffect = Instance.new("BlurEffect"); blurEffect.Name = "AHKKeySysBlur"; blurEffect.Size = 0; blurEffect.Parent = Lighting; local targetBlurSize = 18; local tweenInfoBlurAppear = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out); local tweenBlurAppear = TweenService:Create(blurEffect, tweenInfoBlurAppear, {Size = targetBlurSize}); tweenBlurAppear:Play(); tweenBlurAppear.Completed:Wait()
    screenGui.Parent = player:WaitForChild("PlayerGui"); local tweenInfoUIAppear = TweenInfo.new(0.6, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out); local allAppearTweens = {}; table.insert(allAppearTweens, TweenService:Create(mainFrame, tweenInfoUIAppear, { Size = mainFrameSize, Position = mainFramePos, BackgroundTransparency = 0 })); table.insert(allAppearTweens, TweenService:Create(mainFrameShadow, tweenInfoUIAppear, { BackgroundTransparency = shadowTransparency })); table.insert(allAppearTweens, TweenService:Create(mainFrame:FindFirstChildOfClass("UIStroke"), tweenInfoUIAppear, {Transparency = 0})); local childrenToFadeIn = { titleLabel, keyTextBox, getKeyButton, checkKeyButton, statusLabel }; for _, child in ipairs(childrenToFadeIn) do if child then local props = {}; local stroke = child:FindFirstChildOfClass("UIStroke"); if child.TextTransparency > 0 then props.TextTransparency = 0 end; if child.BackgroundTransparency > 0 and child ~= titleLabel and child ~= statusLabel then props.BackgroundTransparency = 0 end; if next(props) then table.insert(allAppearTweens, TweenService:Create(child, tweenInfoUIAppear, props)) end; if stroke and stroke.Transparency > 0 then table.insert(allAppearTweens, TweenService:Create(stroke, tweenInfoUIAppear, {Transparency = 0})) end end end; for _, tween in ipairs(allAppearTweens) do tween:Play() end

    getKeyButton.MouseButton1Click:Connect(function() statusLabel.Text = ""; statusLabel.TextTransparency = 1; animateGetKeyInfo(not isGetKeyInfoVisible) end)
    checkKeyButton.MouseButton1Click:Connect(function()
        local enteredKey = keyTextBox.Text
        if isGetKeyInfoVisible then animateGetKeyInfo(false); if isGetKeyInfoAnimating then task.wait(0.5) end end
        if not validateKeyFormat(enteredKey) then statusLabel.TextColor3 = colors.error; statusLabel.Text = "Неверный ключ!"; statusLabel.TextTransparency = 0; return end
        statusLabel.TextColor3 = colors.text; statusLabel.Text = "Проверка ключа в Firebase..."; statusLabel.TextTransparency = 0
        checkKeyInFirebase(enteredKey, function(isValid, message, checkedKey)
            if isValid then
                local writeLocalSuccess = markAsLocallyActivated(checkedKey)
                if not writeLocalSuccess then warn("AHK KeySys: Ошибка записи локального truekey.json") end
                statusLabel.TextColor3 = colors.success; statusLabel.Text = message or "Ключ верный! Загрузка..."; statusLabel.TextTransparency = 0
                task.wait(1); task.spawn(executeExternalScripts); cleanupCurrentInstance(true)
            else
                statusLabel.TextColor3 = colors.error; statusLabel.Text = message or "Неверный ключ (Firebase)!"; statusLabel.TextTransparency = 0
            end
        end)
    end)
    keyTextBox.FocusLost:Connect(function(enterPressed) if enterPressed then checkKeyButton.MouseButton1Click:Fire() end end)
end

_G.AHKKeySys_Cleanup = cleanupCurrentInstance
mainLogicCoroutine = coroutine.create(function() if game.PlaceId ~= TARGET_PLACE_ID then confirmationScreenGui = Instance.new("ScreenGui"); confirmationScreenGui.Name = "AHKConfirmationGui"; confirmationScreenGui.ResetOnSpawn = false; confirmationScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; local confirmFrame = Instance.new("Frame"); confirmFrame.Size = UDim2.new(0, 400, 0, 200); confirmFrame.Position = UDim2.new(0.5, 0, 0.5, 0); confirmFrame.AnchorPoint = Vector2.new(0.5, 0.5); confirmFrame.BackgroundColor3 = colors.background; confirmFrame.Parent = confirmationScreenGui; local cfCorner = Instance.new("UICorner"); cfCorner.CornerRadius = UDim.new(0, cornerRadiusLarge); cfCorner.Parent = confirmFrame; local cfStroke = Instance.new("UIStroke"); cfStroke.Color = colors.outline; cfStroke.Thickness = outlineThickness; cfStroke.Parent = confirmFrame; local confirmTitle = Instance.new("TextLabel"); confirmTitle.Size = UDim2.new(1, 0, 0, 40); confirmTitle.BackgroundColor3 = colors.surface; confirmTitle.Text = "Предупреждение"; confirmTitle.Font = Enum.Font.GothamBold; confirmTitle.TextColor3 = colors.text; confirmTitle.TextSize = 20; confirmTitle.Parent = confirmFrame; local confirmText = Instance.new("TextLabel"); confirmText.Size = UDim2.new(0.9, 0, 0, 80); confirmText.Position = UDim2.new(0.5, 0, 0.45, 0); confirmText.AnchorPoint = Vector2.new(0.5, 0.5); confirmText.BackgroundTransparency = 1; confirmText.Text = "Вы зашли в другой режим!\nВы уверены, что хотите запустить данный скрипт?\nНекоторые функции работают только в The Strongest Battlegrounds."; confirmText.Font = Enum.Font.Gotham; confirmText.TextColor3 = colors.text; confirmText.TextSize = 14; confirmText.TextWrapped = true; confirmText.TextXAlignment = Enum.TextXAlignment.Center; confirmText.Parent = confirmFrame; local confirmButton = Instance.new("TextButton"); confirmButton.Name = "ConfirmLaunch"; confirmButton.Size = UDim2.new(0.4, 0, 0, 35); confirmButton.Position = UDim2.new(0.28, 0, 0.8, 0); confirmButton.AnchorPoint = Vector2.new(0.5, 0); confirmButton.BackgroundColor3 = colors.primary; confirmButton.Text = "Подтвердить запуск"; confirmButton.Font = Enum.Font.GothamSemibold; confirmButton.TextColor3 = colors.background; confirmButton.TextSize = 14; confirmButton.Parent = confirmFrame; local cbCorner = Instance.new("UICorner"); cbCorner.CornerRadius = UDim.new(0, cornerRadiusMedium); cbCorner.Parent = confirmButton; local cbStroke = Instance.new("UIStroke"); cbStroke.Color = colors.outline; cbStroke.Thickness = outlineThickness; cbStroke.Parent = confirmButton; local cancelButton = Instance.new("TextButton"); cancelButton.Name = "CancelLaunch"; cancelButton.Size = UDim2.new(0.4, 0, 0, 35); cancelButton.Position = UDim2.new(0.72, 0, 0.8, 0); cancelButton.AnchorPoint = Vector2.new(0.5, 0); cancelButton.BackgroundColor3 = colors.secondary; cancelButton.Text = "Отмена"; cancelButton.Font = Enum.Font.GothamSemibold; cancelButton.TextColor3 = colors.text; cancelButton.TextSize = 14; cancelButton.Parent = confirmFrame; local clbCorner = Instance.new("UICorner"); clbCorner.CornerRadius = UDim.new(0, cornerRadiusMedium); clbCorner.Parent = cancelButton; local clbStroke = Instance.new("UIStroke"); clbStroke.Color = colors.outline; clbStroke.Thickness = outlineThickness; clbStroke.Parent = cancelButton; confirmationScreenGui.Parent = player:WaitForChild("PlayerGui"); confirmButton.MouseButton1Click:Connect(function() if confirmationScreenGui and confirmationScreenGui.Parent then confirmationScreenGui:Destroy(); confirmationScreenGui = nil end; initializeKeySystem() end); cancelButton.MouseButton1Click:Connect(function() if confirmationScreenGui and confirmationScreenGui.Parent then confirmationScreenGui:Destroy(); confirmationScreenGui = nil end; if not alreadyLocallyActivated then local currentCharacter = player.Character; local currentHumanoid = currentCharacter and currentCharacter:FindFirstChildOfClass("Humanoid"); if initialCFrame and rootPart and rootPart.Parent then rootPart.CFrame = initialCFrame end; for i, _ in ipairs(actionsToBlock) do ContextActionService:UnbindAction("AHK_BlockInput_" .. i) end; if currentHumanoid then currentHumanoid.WalkSpeed = 16; currentHumanoid.JumpPower = 50 end; cleanupCurrentInstance(false); return else cleanupCurrentInstance(false); return end end) else initializeKeySystem() end end); coroutine.resume(mainLogicCoroutine)

connectionPlayerRemoving = Players.PlayerRemoving:Connect(function(playerWhoLeft) if playerWhoLeft == player then cleanupCurrentInstance(false) end end)
