--- START OF FILE uiLIB.txt ---

local UILibrary = {}

local function getObjGen()
    local objGen = {}

    local function getObjects()
        local function initObj()
            local Gui = {
                UIObjects = Instance.new("Folder"),
                Cheats = Instance.new("Folder"),
                Button = Instance.new("ImageButton"),
                UICorner = Instance.new("UICorner"),
                DropShadowHolder = Instance.new("Frame"),
                DropShadow = Instance.new("ImageLabel"),
                Text = Instance.new("TextLabel"),
                HoverFrame = Instance.new("Frame"),
                UICorner_2 = Instance.new("UICorner"),
                Checkbox = Instance.new("ImageButton"),
                UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint"),
                Selection = Instance.new("Frame"),
                UICorner_3 = Instance.new("UICorner"),
                UIGradient = Instance.new("UIGradient"),
                HoverFrame_2 = Instance.new("Frame"),
                UICorner_4 = Instance.new("UICorner"),
                Toggle = Instance.new("ImageButton"),
                UIPadding = Instance.new("UIPadding"),
                UIGradient_2 = Instance.new("UIGradient"),
                UICorner_5 = Instance.new("UICorner"),
                DropShadowHolder_2 = Instance.new("Frame"),
                DropShadow_2 = Instance.new("ImageLabel"),
                Content = Instance.new("Frame"),
                Frame = Instance.new("Frame"),
                UICorner_6 = Instance.new("UICorner"),
                UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint"),
                HoverFrame_3 = Instance.new("Frame"),
                UIPadding_2 = Instance.new("UIPadding"),
                UIGradient_3 = Instance.new("UIGradient"),
                UICorner_7 = Instance.new("UICorner"),
                Textbox = Instance.new("Frame"),
                DropShadowHolder_3 = Instance.new("Frame"),
                DropShadow_3 = Instance.new("ImageLabel"),
                UICorner_8 = Instance.new("UICorner"),
                Text_2 = Instance.new("TextBox"),
                UITextSizeConstraint = Instance.new("UITextSizeConstraint"),
                Keybind = Instance.new("ImageButton"),
                UICorner_9 = Instance.new("UICorner"),
                DropShadowHolder_4 = Instance.new("Frame"),
                DropShadow_4 = Instance.new("ImageLabel"),
                Text_3 = Instance.new("TextLabel"),
                HoverFrame_4 = Instance.new("Frame"),
                UICorner_10 = Instance.new("UICorner"),
                ColorPicker = Instance.new("Frame"),
                UIListLayout = Instance.new("UIListLayout"),
                Text_4 = Instance.new("ImageLabel"),
                DropShadowHolder_5 = Instance.new("Frame"),
                DropShadow_5 = Instance.new("ImageLabel"),
                Label = Instance.new("TextBox"),
                Preview = Instance.new("ImageButton"),
                DropShadowHolder_6 = Instance.new("Frame"),
                DropShadow_6 = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint"),
                Hover = Instance.new("ImageLabel"),
                Slider = Instance.new("Frame"),
                Drag = Instance.new("ImageButton"),
                UICorner_11 = Instance.new("UICorner"),
                Frame_2 = Instance.new("Frame"),
                UICorner_12 = Instance.new("UICorner"),
                UIGradient_4 = Instance.new("UIGradient"),
                UIListLayout_2 = Instance.new("UIListLayout"),
                KeyInput = Instance.new("Frame"),
                UICorner_13 = Instance.new("UICorner"),
                DropShadowHolder_7 = Instance.new("Frame"),
                DropShadow_7 = Instance.new("ImageLabel"),
                Text_5 = Instance.new("TextBox"),
                UIListLayout_3 = Instance.new("UIListLayout"),
                Dropdown = Instance.new("Frame"),
                MainHolder = Instance.new("ImageButton"),
                UICorner_14 = Instance.new("UICorner"),
                DropShadowHolder_8 = Instance.new("Frame"),
                DropShadow_8 = Instance.new("ImageLabel"),
                Content_2 = Instance.new("Frame"),
                Text_6 = Instance.new("TextLabel"),
                UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint"),
                UIPadding_3 = Instance.new("UIPadding"),
                UIListLayout_4 = Instance.new("UIListLayout"),
                Icon = Instance.new("Frame"),
                UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint"),
                Holder = Instance.new("Frame"),
                Icon_2 = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_5 = Instance.new("UIAspectRatioConstraint"),
                UIListLayout_5 = Instance.new("UIListLayout"),
                OptionHolder = Instance.new("Frame"),
                Cover = Instance.new("Frame"),
                DropShadow_9 = Instance.new("ImageLabel"),
                UICorner_15 = Instance.new("UICorner"),
                UIPadding_4 = Instance.new("UIPadding"),
                UICorner_16 = Instance.new("UICorner"),
                ContentHolder = Instance.new("Frame"),
                Content_3 = Instance.new("ScrollingFrame"),
                UIListLayout_6 = Instance.new("UIListLayout"),
                Bottom = Instance.new("ImageButton"),
                Current = Instance.new("TextLabel"),
                Select = Instance.new("ImageLabel"),
                Slot = Instance.new("ImageButton"),
                Line = Instance.new("Frame"),
                Select_2 = Instance.new("ImageLabel"),
                Current_2 = Instance.new("TextLabel"),
                Top = Instance.new("ImageButton"),
                Line_2 = Instance.new("Frame"),
                Select_3 = Instance.new("ImageLabel"),
                Current_3 = Instance.new("TextLabel"),
                Objects = Instance.new("Folder"),
                Category = Instance.new("ImageButton"),
                HoverFrame_5 = Instance.new("Frame"),
                Content_4 = Instance.new("Frame"),
                Image = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_6 = Instance.new("UIAspectRatioConstraint"),
                Title = Instance.new("TextLabel"),
                UITextSizeConstraint_3 = Instance.new("UITextSizeConstraint"),
                UIListLayout_7 = Instance.new("UIListLayout"),
                CategoryContent = Instance.new("Frame"),
                Bar2Holder = Instance.new("Frame"),
                UIListLayout_8 = Instance.new("UIListLayout"),
                UIListLayout_9 = Instance.new("UIListLayout"),
                UIPadding_5 = Instance.new("UIPadding"),
                Window = Instance.new("Frame"),
                Watermark = Instance.new("TextLabel"),
                UIPadding_6 = Instance.new("UIPadding"),
                MainUI = Instance.new("Frame"),
                DropShadowHolder_9 = Instance.new("Frame"),
                DropShadow_10 = Instance.new("ImageLabel"),
                UICorner_17 = Instance.new("UICorner"),
                Sidebar = Instance.new("Frame"),
                ContentHolder_2 = Instance.new("Frame"),
                UserInfo = Instance.new("Frame"),
                Content_5 = Instance.new("Frame"),
                Rank = Instance.new("TextLabel"),
                UIPadding_7 = Instance.new("UIPadding"),
                UIListLayout_10 = Instance.new("UIListLayout"),
                Title_2 = Instance.new("TextLabel"),
                Line_3 = Instance.new("Frame"),
                Fill = Instance.new("ImageLabel"),
                Texture = Instance.new("ImageLabel"),
                UIListLayout_11 = Instance.new("UIListLayout"),
                Cheats_2 = Instance.new("Frame"),
                UIListLayout_12 = Instance.new("UIListLayout"),
                UIPadding_8 = Instance.new("UIPadding"),
                Logo = Instance.new("ImageLabel"),
                UIGradient_5 = Instance.new("UIGradient"),
                CheatHolder = Instance.new("Frame"),
                UIListLayout_13 = Instance.new("UIListLayout"),
                Fill_2 = Instance.new("ImageLabel"),
                DivLine = Instance.new("Frame"),
                Tab2 = Instance.new("ImageLabel"),
                Shadow = Instance.new("Frame"),
                UIGradient_6 = Instance.new("UIGradient"),
                Sidebar2 = Instance.new("Frame"),
                UIAspectRatioConstraint_7 = Instance.new("UIAspectRatioConstraint"),
                ColorPickerOverlay = Instance.new("ImageButton"),
                Content_6 = Instance.new("Frame"),
                MainWindow = Instance.new("Frame"),
                Wheel = Instance.new("ImageLabel"),
                Hitbox = Instance.new("ImageButton"),
                Shadow_2 = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_8 = Instance.new("UIAspectRatioConstraint"),
                Pointer = Instance.new("ImageLabel"),
                UIListLayout_14 = Instance.new("UIListLayout"),
                Saturation = Instance.new("ImageLabel"),
                DropShadowHolder_10 = Instance.new("Frame"),
                DropShadow_11 = Instance.new("ImageLabel"),
                Pointer_2 = Instance.new("ImageLabel"),
                UIGradient_7 = Instance.new("UIGradient"),
                Hitbox_2 = Instance.new("ImageButton"),
                UIListLayout_15 = Instance.new("UIListLayout"),
                ClrDisplay = Instance.new("Frame"),
                UIListLayout_16 = Instance.new("UIListLayout"),
                RGB = Instance.new("ImageLabel"),
                Textbox_2 = Instance.new("TextLabel"),
                DropShadowHolder_11 = Instance.new("Frame"),
                DropShadow_12 = Instance.new("ImageLabel"),
                Header = Instance.new("TextLabel"),
                Hex = Instance.new("ImageLabel"),
                DropShadowHolder_12 = Instance.new("Frame"),
                DropShadow_13 = Instance.new("ImageLabel"),
                Textbox_3 = Instance.new("TextLabel"),
                Header_2 = Instance.new("TextLabel"),
                UIAspectRatioConstraint_9 = Instance.new("UIAspectRatioConstraint"),
                Buttons = Instance.new("Frame"),
                Confirm = Instance.new("ImageButton"),
                Confirm_2 = Instance.new("TextLabel"),
                DropShadowHolder_13 = Instance.new("Frame"),
                DropShadow_14 = Instance.new("ImageLabel"),
                Checkmark = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_10 = Instance.new("UIAspectRatioConstraint"),
                OtherFill = Instance.new("ImageLabel"),
                UIListLayout_17 = Instance.new("UIListLayout"),
                Cancel = Instance.new("ImageButton"),
                OtherFill_2 = Instance.new("ImageLabel"),
                DropShadowHolder_14 = Instance.new("Frame"),
                DropShadow_15 = Instance.new("ImageLabel"),
                Checkmark_2 = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_11 = Instance.new("UIAspectRatioConstraint"),
                Content_7 = Instance.new("Frame"),
                Shadow_3 = Instance.new("Frame"),
                UIGradient_8 = Instance.new("UIGradient"),
                UICorner_18 = Instance.new("UICorner"),
                Notifications = Instance.new("Frame"),
                UIListLayout_18 = Instance.new("UIListLayout"),
                CategoryButton = Instance.new("ImageButton"),
                InnerContent = Instance.new("Frame"),
                UIListLayout_19 = Instance.new("UIListLayout"),
                Image_2 = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_12 = Instance.new("UIAspectRatioConstraint"),
                Title_3 = Instance.new("TextLabel"),
                UITextSizeConstraint_4 = Instance.new("UITextSizeConstraint"),
                SelectionShadow = Instance.new("Frame"),
                UIGradient_9 = Instance.new("UIGradient"),
                HoverFrame_6 = Instance.new("Frame"),
                CategoryFrame = Instance.new("ScrollingFrame"),
                Left = Instance.new("Frame"),
                UIPadding_9 = Instance.new("UIPadding"),
                UIListLayout_20 = Instance.new("UIListLayout"),
                Right = Instance.new("Frame"),
                UIListLayout_21 = Instance.new("UIListLayout"),
                UIPadding_10 = Instance.new("UIPadding"),
                UIPadding_11 = Instance.new("UIPadding"),
                Section = Instance.new("Frame"),
                Border = Instance.new("Frame"),
                SectionTitle = Instance.new("TextLabel"),
                UITextSizeConstraint_5 = Instance.new("UITextSizeConstraint"),
                UICorner_19 = Instance.new("UICorner"),
                Content_8 = Instance.new("Frame"),
                UIPadding_12 = Instance.new("UIPadding"),
                UIListLayout_22 = Instance.new("UIListLayout"),
                DropShadow_16 = Instance.new("ImageLabel"),
                CheatBase = Instance.new("Frame"),
                Content_9 = Instance.new("Frame"),
                UIListLayout_23 = Instance.new("UIListLayout"),
                Text_7 = Instance.new("Frame"),
                Text_8 = Instance.new("TextLabel"),
                Desc = Instance.new("TextLabel"),
                ElementContent = Instance.new("Frame"),
                UIListLayout_24 = Instance.new("UIListLayout"),
                Notification = Instance.new("Frame"),
                Main = Instance.new("Frame"),
                DropShadowHolder_15 = Instance.new("Frame"),
                DropShadow_17 = Instance.new("ImageLabel"),
                Content_10 = Instance.new("Frame"),
                UIListLayout_25 = Instance.new("UIListLayout"),
                Line_4 = Instance.new("Frame"),
                Buttons_2 = Instance.new("Frame"),
                UIListLayout_26 = Instance.new("UIListLayout"),
                Close = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_13 = Instance.new("UIAspectRatioConstraint"),
                Text_9 = Instance.new("Frame"),
                UIListLayout_27 = Instance.new("UIListLayout"),
                Title_4 = Instance.new("TextLabel"),
                Desc_2 = Instance.new("TextLabel"),
                UIPadding_13 = Instance.new("UIPadding"),
                UICorner_20 = Instance.new("UICorner"),
                UIAspectRatioConstraint_14 = Instance.new("UIAspectRatioConstraint"),
                Notification_2 = Instance.new("Frame"),
                UICorner_21 = Instance.new("UICorner"),
                Prompt = Instance.new("Frame"),
                Main_2 = Instance.new("Frame"),
                UICorner_22 = Instance.new("UICorner"),
                DropShadowHolder_16 = Instance.new("Frame"),
                DropShadow_18 = Instance.new("ImageLabel"),
                Content_11 = Instance.new("Frame"),
                UIListLayout_28 = Instance.new("UIListLayout"),
                Line_5 = Instance.new("Frame"),
                Buttons_3 = Instance.new("Frame"),
                UIListLayout_29 = Instance.new("UIListLayout"),
                Accept = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_15 = Instance.new("UIAspectRatioConstraint"),
                Close_2 = Instance.new("ImageLabel"),
                UIAspectRatioConstraint_16 = Instance.new("UIAspectRatioConstraint"),
                Text_10 = Instance.new("Frame"),
                UIListLayout_30 = Instance.new("UIListLayout"),
                Title_5 = Instance.new("TextLabel"),
                Desc_3 = Instance.new("TextLabel"),
                UIPadding_14 = Instance.new("UIPadding"),
                Notification_3 = Instance.new("Frame"),
                UICorner_23 = Instance.new("UICorner"),
                UIAspectRatioConstraint_17 = Instance.new("UIAspectRatioConstraint"),
                LabelElement = Instance.new("Frame"),
                UIListLayout_Label = Instance.new("UIListLayout"),
                UIPadding_Label = Instance.new("UIPadding"),
                Title_Label = Instance.new("TextLabel"),
                Desc_Label = Instance.new("TextLabel"),

                Objects = Instance.new("Folder")
            }

            local function setupInteractiveButton(buttonInstance, needsBackground)
                buttonInstance.AutoButtonColor = false
                buttonInstance.Selectable = true
                if needsBackground == false then
                    buttonInstance.BackgroundTransparency = 1
                else
                    buttonInstance.BackgroundTransparency = 0
                end
            end

            Gui.UIObjects.Name = "UIObjects"

            Gui.Cheats.Name = "Cheats"
            Gui.Cheats.Parent = Gui.UIObjects

            Gui.Button.Name = "Button"
            Gui.Button.Parent = Gui.Cheats
            setupInteractiveButton(Gui.Button, true)
            Gui.Button.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
            Gui.Button.BorderColor3 = Color3.fromRGB(27, 42, 53)
            Gui.Button.BorderSizePixel = 0
            Gui.Button.Size = UDim2.new(1, 0, 1, 0)
            Gui.Button.ZIndex = 110
            Gui.UICorner.Parent = Gui.Button
            Gui.DropShadowHolder.Parent = Gui.Button
            Gui.Text.Parent = Gui.Button
            Gui.HoverFrame.Parent = Gui.Button


            Gui.Checkbox.Name = "Checkbox"
            Gui.Checkbox.Parent = Gui.Cheats
            setupInteractiveButton(Gui.Checkbox, true)
            Gui.Checkbox.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
            Gui.Checkbox.BorderSizePixel = 0
            Gui.Checkbox.Size = UDim2.new(0.779999971, 0, 0.779999971, 0)
            Gui.Checkbox.ZIndex = 110
            Gui.UIAspectRatioConstraint.Parent = Gui.Checkbox
            Gui.Selection.Parent = Gui.Checkbox
            Gui.HoverFrame_2.Parent = Gui.Checkbox
            Gui.UICorner_4.Parent = Gui.Checkbox

            Gui.Toggle.Name = "Toggle"
            Gui.Toggle.Parent = Gui.Cheats
            setupInteractiveButton(Gui.Toggle, true)
            Gui.Toggle.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
            Gui.Toggle.BorderSizePixel = 0
            Gui.Toggle.Size = UDim2.new(0.300000012, 0, 0.600000024, 0)
            Gui.Toggle.ZIndex = 110
            Gui.UIPadding.Parent = Gui.Toggle
            Gui.UIGradient_2.Parent = Gui.Toggle
            Gui.UICorner_5.Parent = Gui.Toggle
            Gui.DropShadowHolder_2.Parent = Gui.Toggle
            Gui.Content.Parent = Gui.Toggle
            Gui.HoverFrame_3.Parent = Gui.Toggle


            Gui.Keybind.Name = "Keybind"
            Gui.Keybind.Parent = Gui.Cheats
            setupInteractiveButton(Gui.Keybind, true)
            Gui.Keybind.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
            Gui.Keybind.BorderSizePixel = 0
            Gui.Keybind.Size = UDim2.new(0.200000003, 0, 1, 0)
            Gui.Keybind.ZIndex = 110
            Gui.UICorner_9.Parent = Gui.Keybind
            Gui.DropShadowHolder_4.Parent = Gui.Keybind
            Gui.Text_3.Parent = Gui.Keybind
            Gui.HoverFrame_4.Parent = Gui.Keybind

            Gui.Drag.Name = "Drag"
            Gui.Drag.Parent = Gui.Slider
            setupInteractiveButton(Gui.Drag, true)
            Gui.Drag.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            Gui.Drag.BorderSizePixel = 0
            Gui.Drag.LayoutOrder = -1
            Gui.Drag.Size = UDim2.new(0.75, 0, 0.200000003, 0)
            Gui.Drag.ZIndex = 110
            Gui.UICorner_11.Parent = Gui.Drag
            Gui.Frame_2.Parent = Gui.Drag
            Gui.UIListLayout_2.Parent = Gui.Drag

            Gui.MainHolder.Name = "MainHolder"
            Gui.MainHolder.Parent = Gui.Dropdown
            setupInteractiveButton(Gui.MainHolder, true)
            Gui.MainHolder.AnchorPoint = Vector2.new(0, 0.5)
            Gui.MainHolder.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
            Gui.MainHolder.BorderSizePixel = 0
            Gui.MainHolder.Size = UDim2.new(1, 0, 0.850000024, 0)
            Gui.MainHolder.ZIndex = 111
            Gui.UICorner_14.Parent = Gui.MainHolder
            Gui.DropShadowHolder_8.Parent = Gui.MainHolder
            Gui.Content_2.Parent = Gui.MainHolder


            Gui.Category.Name = "Category"
            Gui.Category.Parent = Gui.Objects
            setupInteractiveButton(Gui.Category, false)
            Gui.Category.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            Gui.Category.BorderSizePixel = 0
            Gui.Category.LayoutOrder = 1
            Gui.Category.Size = UDim2.new(1, 0, 0.25, 0)
            Gui.Category.ZIndex = 121
            Gui.HoverFrame_5.Parent = Gui.Category
            Gui.Content_4.Parent = Gui.Category


            Gui.CategoryButton.Name = "CategoryButton"
            Gui.CategoryButton.Parent = Gui.Objects
            setupInteractiveButton(Gui.CategoryButton, false)
            Gui.CategoryButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            Gui.CategoryButton.BorderSizePixel = 0
            Gui.CategoryButton.Size = UDim2.new(1, 0, 0.200000003, 0)
            Gui.CategoryButton.ZIndex = 121
            Gui.InnerContent.Parent = Gui.CategoryButton
            Gui.SelectionShadow.Parent = Gui.CategoryButton
            Gui.HoverFrame_6.Parent = Gui.CategoryButton

            Gui.Textbox.Name = "Textbox"; Gui.Textbox.Parent = Gui.Cheats;
            Gui.Textbox.AnchorPoint = Vector2.new(0, 0.5); Gui.Textbox.BackgroundColor3 = Color3.fromRGB(25, 25, 25); Gui.Textbox.BorderColor3 = Color3.fromRGB(27, 42, 53); Gui.Textbox.BorderSizePixel = 0; Gui.Textbox.Position = UDim2.new(0, 0, 0.5, 0); Gui.Textbox.Size = UDim2.new(1, 0, 1, 0); Gui.Textbox.ZIndex = 110;
            Gui.DropShadowHolder_3.Parent = Gui.Textbox; Gui.UICorner_8.Parent = Gui.Textbox; Gui.Text_2.Parent = Gui.Textbox;

            Gui.ColorPicker.Name = "ColorPicker"; Gui.ColorPicker.Parent = Gui.Cheats;
            Gui.ColorPicker.BackgroundColor3 = Color3.fromRGB(255, 255, 255); Gui.ColorPicker.BackgroundTransparency = 1.000; Gui.ColorPicker.BorderSizePixel = 0; Gui.ColorPicker.Position = UDim2.new(0.600000024, -8, 0, 0); Gui.ColorPicker.Size = UDim2.new(1, 0, 1, 0); Gui.ColorPicker.ZIndex = 200;
            Gui.UIListLayout.Parent = Gui.ColorPicker; Gui.Text_4.Parent = Gui.ColorPicker; Gui.Preview.Parent = Gui.ColorPicker;

            Gui.Slider.Name = "Slider"; Gui.Slider.Parent = Gui.Cheats;
            Gui.Slider.BackgroundColor3 = Color3.fromRGB(255, 255, 255); Gui.Slider.BackgroundTransparency = 1.000; Gui.Slider.Size = UDim2.new(1, 0, 1, 0);
            Gui.KeyInput.Parent = Gui.Slider; Gui.UIListLayout_3.Parent = Gui.Slider;

            Gui.Dropdown.Name = "Dropdown"; Gui.Dropdown.Parent = Gui.Cheats;
            Gui.Dropdown.BackgroundColor3 = Color3.fromRGB(255, 255, 255); Gui.Dropdown.Size = UDim2.new(1, 0, 1, 0);
            Gui.UIListLayout_5.Parent = Gui.Dropdown; Gui.OptionHolder.Parent = Gui.Dropdown;
            Gui.Bottom.Parent = Gui.Dropdown; Gui.Slot.Parent = Gui.Dropdown; Gui.Top.Parent = Gui.Dropdown;

            Gui.Window.Parent = Gui.Objects; Gui.Watermark.Parent = Gui.Window; Gui.UIPadding_6.Parent = Gui.Window; Gui.MainUI.Parent = Gui.Window;
            Gui.DropShadowHolder_9.Parent = Gui.MainUI; Gui.UICorner_17.Parent = Gui.MainUI; Gui.Sidebar.Parent = Gui.MainUI; Gui.ColorPickerOverlay.Parent = Gui.MainUI; Gui.Content_7.Parent = Gui.MainUI; Gui.UIAspectRatioConstraint_7.Parent = Gui.MainUI; Gui.Notifications.Parent = Gui.Window;
            Gui.ContentHolder_2.Parent = Gui.Sidebar; Gui.Fill_2.Parent = Gui.Sidebar; Gui.Tab2.Parent = Gui.Sidebar; Gui.Sidebar2.Parent = Gui.Sidebar;
            Gui.UserInfo.Parent = Gui.ContentHolder_2; Gui.UIListLayout_11.Parent = Gui.ContentHolder_2; Gui.Cheats_2.Parent = Gui.ContentHolder_2;
            Gui.Content_5.Parent = Gui.UserInfo; Gui.Line_3.Parent = Gui.UserInfo; Gui.Fill.Parent = Gui.UserInfo; Gui.Texture.Parent = Gui.UserInfo;
            Gui.Rank.Parent = Gui.Content_5; Gui.UIPadding_7.Parent = Gui.Content_5; Gui.UIListLayout_10.Parent = Gui.Content_5; Gui.Title_2.Parent = Gui.Content_5;
            Gui.UIListLayout_12.Parent = Gui.Cheats_2; Gui.UIPadding_8.Parent = Gui.Cheats_2; Gui.Logo.Parent = Gui.Cheats_2; Gui.CheatHolder.Parent = Gui.Cheats_2;
            Gui.Shadow.Parent = Gui.Tab2;
            Gui.Content_6.Parent = Gui.ColorPickerOverlay;
            Gui.MainWindow.Parent = Gui.Content_6; Gui.UIListLayout_15.Parent = Gui.Content_6; Gui.ClrDisplay.Parent = Gui.Content_6; Gui.UIAspectRatioConstraint_9.Parent = Gui.Content_6; Gui.Buttons.Parent = Gui.Content_6;
            Gui.Wheel.Parent = Gui.MainWindow; Gui.UIListLayout_14.Parent = Gui.MainWindow; Gui.Saturation.Parent = Gui.MainWindow;
            Gui.Hitbox.Parent = Gui.Wheel; Gui.Shadow_2.Parent = Gui.Wheel; Gui.UIAspectRatioConstraint_8.Parent = Gui.Wheel; Gui.Pointer.Parent = Gui.Wheel;
            Gui.DropShadowHolder_10.Parent = Gui.Saturation; Gui.Pointer_2.Parent = Gui.Saturation; Gui.UIGradient_7.Parent = Gui.Saturation; Gui.Hitbox_2.Parent = Gui.Saturation;
            Gui.UIListLayout_16.Parent = Gui.ClrDisplay; Gui.RGB.Parent = Gui.ClrDisplay; Gui.Hex.Parent = Gui.ClrDisplay;
            Gui.Textbox_2.Parent = Gui.RGB; Gui.DropShadowHolder_11.Parent = Gui.RGB; Gui.Header.Parent = Gui.RGB;
            Gui.DropShadowHolder_12.Parent = Gui.Hex; Gui.Textbox_3.Parent = Gui.Hex; Gui.Header_2.Parent = Gui.Hex;
            Gui.Confirm.Parent = Gui.Buttons; Gui.UIListLayout_17.Parent = Gui.Buttons; Gui.Cancel.Parent = Gui.Buttons;
            Gui.Shadow_3.Parent = Gui.Content_7;
            Gui.CategoryFrame.Parent = Gui.Objects; Gui.Left.Parent = Gui.CategoryFrame; Gui.Right.Parent = Gui.CategoryFrame; Gui.UIPadding_11.Parent = Gui.CategoryFrame;
            Gui.Section.Parent = Gui.Objects; Gui.Border.Parent = Gui.Section; Gui.DropShadow_16.Parent = Gui.Section;
            Gui.SectionTitle.Parent = Gui.Border; Gui.UICorner_19.Parent = Gui.Border; Gui.Content_8.Parent = Gui.Border;
            Gui.CheatBase.Parent = Gui.Objects; Gui.Content_9.Parent = Gui.CheatBase;
            Gui.UIListLayout_23.Parent = Gui.Content_9; Gui.Text_7.Parent = Gui.Content_9; Gui.ElementContent.Parent = Gui.Content_9;
            Gui.Notification.Parent = Gui.Objects; Gui.Main.Parent = Gui.Notification;
            Gui.DropShadowHolder_15.Parent = Gui.Main; Gui.Content_10.Parent = Gui.Main; Gui.UICorner_20.Parent = Gui.Main; Gui.UIAspectRatioConstraint_14.Parent = Gui.Main; Gui.Notification_2.Parent = Gui.Main;
            Gui.Prompt.Parent = Gui.Objects; Gui.Main_2.Parent = Gui.Prompt;
            Gui.UICorner_22.Parent = Gui.Main_2; Gui.DropShadowHolder_16.Parent = Gui.Main_2; Gui.Content_11.Parent = Gui.Main_2; Gui.Notification_3.Parent = Gui.Main_2; Gui.UIAspectRatioConstraint_17.Parent = Gui.Main_2;
            Gui.LabelElement.Parent = Gui.Objects; Gui.UIListLayout_Label.Parent = Gui.LabelElement; Gui.UIPadding_Label.Parent = Gui.LabelElement; Gui.Title_Label.Parent = Gui.LabelElement; Gui.Desc_Label.Parent = Gui.LabelElement;


            return Gui.UIObjects
        end

        return initObj()
    end

    local UIObjects = getObjects()
    UIObjects.Parent = script

    for i, v_obj in pairs(script.UIObjects:GetChildren()) do
        v_obj.Parent = v_obj.Parent.Parent
    end

    script.UIObjects:Destroy()

    function objGen.new(objectType, cheatName)
        if objectType == "Cheat" then
            if script.Cheats:FindFirstChild(cheatName) then
                return script.Cheats[cheatName]:Clone()
            else
                error("Invalid cheatType: " .. tostring(cheatName))
            end
        end

        if script.Objects:FindFirstChild(objectType) then
            return script.Objects[objectType]:Clone()
        else
            error("Invalid objectType: " .. tostring(objectType))
        end
    end

    return objGen
end

local objectGenerator = getObjGen()


local function initUtils()
    local utils = {}
    local camera = workspace.CurrentCamera
    local centre = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)

    camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
        centre = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
    end)


    utils.OffsetToScale = function(Offset)
        local viewportSize = camera.ViewportSize
        if viewportSize.X == 0 or viewportSize.Y == 0 then return {0,0} end
        return ({Offset[1] / viewportSize.X, Offset[2] / viewportSize.Y})
    end

    utils.ScaleToOffset = function(Scale)
        local viewportSize = camera.ViewportSize
        local X = Scale[1] * viewportSize.X
        local Y = Scale[2] * viewportSize.Y
        return X , Y
    end

    utils.CheckBoundary = function(Boundary,Object,Change)
        if Boundary then
            local Size = Boundary.AbsoluteSize
            local Position = Boundary.AbsolutePosition

            local Min = -(Size-Position) + Size
            local Max = (Size+Position) - Object.AbsoluteSize

            local ObjPos = Object.Position
            local X_Obj, Y_Obj = Utils.ScaleToOffset({ObjPos.X.Scale,ObjPos.Y.Scale})

            local GuiVector = Vector2.new(ObjPos.X.Offset+Change.X+X_Obj,ObjPos.Y.Offset+Change.Y+Y_Obj)

            local X_Boundary = math.clamp(GuiVector.X,Min.X,Max.X)
            local Y_Boundary = math.clamp(GuiVector.Y,Min.Y,Max.Y)

            return X_Boundary , Y_Boundary
        end
        local ObjPosFallback = Object.Position
        local X_Obj_Fallback, Y_Obj_Fallback = Utils.ScaleToOffset({ObjPosFallback.X.Scale,ObjPosFallback.Y.Scale})
        return ObjPosFallback.X.Offset+Change.X+X_Obj_Fallback, ObjPosFallback.Y.Offset+Change.Y+Y_Obj_Fallback
    end

    utils.SortTable = function(Clippings , Current , Object)
        Clippings = Clippings or {}
        Current = Current or {}
        local Suitable
        local CurrentDist

        pcall(function()
            if Object then
                for _ , v_item in ipairs(Current) do
                    if table.find(Clippings,v_item) and v_item.ZIndex <= Object.ZIndex then
                        if not CurrentDist then
                            CurrentDist = (Object.AbsolutePosition-v_item.AbsolutePosition).Magnitude
                            Suitable = v_item
                        else
                            local Dist = (Object.AbsolutePosition-v_item.AbsolutePosition).Magnitude
                            if Dist < CurrentDist then
                                CurrentDist = Dist
                                Suitable = v_item
                            end
                        end
                    end
                end
            end
        end)

        return Suitable
    end

    utils.Side = function(E)
        if E >= -135 and E <= -45 then
            return 'Left'
        elseif E <= 45 and E > -45 then
            return 'Down'
        elseif E  <= 135 and E > 45 then
            return 'Right'
        else
            return 'Up'
        end
    end


    utils.Snap = function(B,C,Target)
        local aPos = C.AbsolutePosition - centre
        local bPos_obj = B.AbsolutePosition - centre
        local relativePos = aPos - bPos_obj


        local Dot = math.deg(math.atan2(relativePos.X, relativePos.Y))

        local SideGot = utils.Side(Dot)
        local SizeB = B.Size
        local CSize = C.Size

        local CSizeX,CSizeY= table.unpack(Utils.OffsetToScale({CSize.X.Offset,CSize.Y.Offset}))
        CSizeX = CSizeX + CSize.X.Scale
        CSizeY = CSizeY + CSize.Y.Scale

        local Size1,Size2 = table.unpack(Utils.OffsetToScale({SizeB.X.Offset,SizeB.Y.Offset}))
        Size1 = Size1 + SizeB.X.Scale
        Size2 = Size2 + SizeB.Y.Scale

        local SizeArr = {Size1,Size2}

        local Pos1,Pos2 = table.unpack(Utils.OffsetToScale({B.Position.X.Offset,B.Position.Y.Offset}))
        local X_Snap =  (Target and Utils.OffsetToScale({Target.X.Offset,0})[1])  or Utils.OffsetToScale({C.Position.X.Offset,0})[1]
        local Y_Snap =  (Target and Utils.OffsetToScale({0,Target.Y.Offset})[2])  or Utils.OffsetToScale({0,C.Position.Y.Offset})[2]

        if SideGot == 'Up' then
            local Pos = UDim2.new(X_Snap,0,Pos2+B.Position.Y.Scale,0)
            SizeArr[2] = SizeArr[2] + CSizeY-Size2
            return Pos+ UDim2.new(0,0,-SizeArr[2],0)
        elseif SideGot == 'Down' then
            local Pos = UDim2.new(X_Snap,0,Pos2+B.Position.Y.Scale,0)
            return Pos+ UDim2.new(0,0,SizeArr[2],0)
        elseif SideGot == 'Left' then
            local Pos = UDim2.new(Pos1+B.Position.X.Scale,0,Y_Snap,0)
            SizeArr[1] = SizeArr[1] + CSizeX-Size1
            return Pos+ UDim2.new(-SizeArr[1],0,0,0)
        elseif SideGot == 'Right' then
            local Pos = UDim2.new(Pos1+B.Position.X.Scale,0,Y_Snap,0)
            return Pos+ UDim2.new(SizeArr[1],0,0,0)
        end
        return C.Position -- Fallback
    end

    return utils

end

local function getDragIt()
    local RS = game:GetService("RunService")
    local IsClient = RS:IsClient()

    if IsClient then
        local UIS = game:GetService("UserInputService")
        local Utils = initUtils()
        local Player = game.Players.LocalPlayer

        local drag = {}
        local Events = {}
        local RenderConnection
        local GuiObject = {}
        GuiObject.__index = GuiObject
        local Objects = {}
        local Settings = { Priority = "Snapping" }

        local dragData = {
            isDragging = false,
            inputObject = nil,
            lastPosition = nil, -- Vector2
            draggedObjectInstance = nil
        }

        function GuiObject:SetData(Data)
            for i, v_data in pairs(Data) do
                self[i] = v_data
            end
        end

        function GuiObject:Destroy()
            local Index = table.find(Objects, self)
            if Index then
                if Events[self] then
                    for _, v_event in ipairs(Events[self]) do
                        if v_event then v_event:Destroy() end
                    end
                    Events[self] = nil
                end
                if self._InputCheck then self._InputCheck:Disconnect(); self._InputCheck = nil; end
                if self._InputChangedConnection then self._InputChangedConnection:Disconnect(); self._InputChangedConnection = nil; end


                if dragData.draggedObjectInstance == self then
                    dragData.isDragging = false
                    dragData.inputObject = nil
                    dragData.lastPosition = nil
                    dragData.draggedObjectInstance = nil
                    if RenderConnection then RenderConnection:Disconnect(); RenderConnection = nil; end
                end

                table.remove(Objects, Index)
                if #Objects == 0 and RenderConnection then
                    RenderConnection:Disconnect()
                    RenderConnection = nil
                end
            end
        end

        drag.Drag = function(Gui, setTo, Boundary, Clippings, AutoClip, ResponseTime, Snappings)
            local self = {}
            self.Boundary = Boundary
            self.Object = Gui
            self.Clippings = Clippings
            self.CanDrag = false
            self.OldPosition = nil -- Vector2
            self.Clipped = nil
            self.AutoClip = AutoClip
            self.ResponseTime = (ResponseTime and math.abs(ResponseTime))
            self.Snappings = Snappings
            self.Snap = nil

            self._InputCheck = setTo.InputBegan:Connect(function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 or (Input.UserInputType == Enum.UserInputType.Touch and Input.UserInputState == Enum.UserInputState.Begin) then
                    local canSetDrag = true
                    for _, v_check in ipairs(Objects) do
                        if v_check.isCurrentlyBeingDragged then
                            canSetDrag = false
                            break
                        end
                    end
                    if dragData.isDragging then canSetDrag = false end


                    if canSetDrag then
                        self.CanDrag = true
                        Events[self][1]:Fire()

                        if self._InputChangedConnection then self._InputChangedConnection:Disconnect() end
                        self._InputChangedConnection = Input.Changed:Connect(function()
                            if Input.UserInputState == Enum.UserInputState.End then
                                self.CanDrag = false
                                self.isCurrentlyBeingDragged = false
                                Events[self][2]:Fire()
                                if self._InputChangedConnection then self._InputChangedConnection:Disconnect(); self._InputChangedConnection = nil; end
                            end
                        end)
                    end
                end
            end)

            local DragStart = Instance.new("BindableEvent")
            local DragEnd = Instance.new("BindableEvent")
            self.DragStart = DragStart.Event
            self.DragEnd = DragEnd.Event
            Events[self] = {DragStart, DragEnd}
            setmetatable(self, GuiObject)
            table.insert(Objects, self)
            return self
        end

        UIS.InputBegan:Connect(function(Input, gp)
            if gp then return end

            if Input.UserInputType == Enum.UserInputType.MouseButton1 or (Input.UserInputType == Enum.UserInputType.Touch and Input.UserInputState == Enum.UserInputState.Begin) then
                local objectToDrag = nil
                for _, v_obj in ipairs(Objects) do
                    if v_obj.CanDrag then
                        objectToDrag = v_obj
                        break
                    end
                end

                if objectToDrag and not dragData.isDragging then
                    dragData.isDragging = true
                    dragData.inputObject = Input
                    dragData.lastPosition = Vector2.new(Input.Position.X, Input.Position.Y)
                    dragData.draggedObjectInstance = objectToDrag
                    objectToDrag.OldPosition = Vector2.new(Input.Position.X, Input.Position.Y)
                    objectToDrag.isCurrentlyBeingDragged = true


                    if not RenderConnection then
                        RenderConnection = RS.RenderStepped:Connect(function(DT)
                            if not dragData.isDragging or not dragData.inputObject or not dragData.draggedObjectInstance then
                                if RenderConnection then RenderConnection:Disconnect(); RenderConnection = nil; end
                                return
                            end

                            local currentPointerPosVector2
                            if dragData.inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
                                local mouseLoc = UIS:GetMouseLocation()
                                currentPointerPosVector2 = Vector2.new(mouseLoc.X, mouseLoc.Y)
                            elseif dragData.inputObject.UserInputType == Enum.UserInputType.Touch then
                                local foundTouch = false
                                for _, touch_obj in ipairs(UIS:GetTouches()) do
                                    if touch_obj.TouchId == dragData.inputObject.TouchId then
                                        currentPointerPosVector2 = Vector2.new(touch_obj.Position.X, touch_obj.Position.Y)
                                        dragData.inputObject = touch_obj
                                        foundTouch = true
                                        break
                                    end
                                end
                                if not foundTouch then
                                    dragData.isDragging = false
                                    if dragData.draggedObjectInstance then dragData.draggedObjectInstance.isCurrentlyBeingDragged = false end
                                    if RenderConnection then RenderConnection:Disconnect(); RenderConnection = nil; end
                                    return
                                end
                            else
                                if RenderConnection then RenderConnection:Disconnect(); RenderConnection = nil; end
                                return
                            end

                            if not currentPointerPosVector2 then
                                if RenderConnection then RenderConnection:Disconnect(); RenderConnection = nil; end
                                return
                            end

                            local v_active = dragData.draggedObjectInstance
                            local pos_active = v_active.Object.Position
                            local change_active = currentPointerPosVector2 - v_active.OldPosition

                            local scaleX_active, scaleY_active = Utils.ScaleToOffset({pos_active.X.Scale, pos_active.Y.Scale})
                            local newPos_active = UDim2.new(
                                0, pos_active.X.Offset + change_active.X + scaleX_active,
                                0, pos_active.Y.Offset + change_active.Y + scaleY_active
                            )

                            if v_active.Boundary then
                                local X_b, Y_b = Utils.CheckBoundary(v_active.Boundary, v_active.Object, change_active) -- Renamed X, Y
                                newPos_active = UDim2.new(0, X_b, 0, Y_b)
                            end
                            local Alpha_active = v_active.ResponseTime and (DT * 7 * v_active.ResponseTime) or 1

                            v_active._Target = newPos_active
                            v_active.Object.Position = v_active.Object.Position:Lerp(newPos_active, Alpha_active)
                            v_active.OldPosition = v_active.OldPosition:Lerp(currentPointerPosVector2, Alpha_active)

                            local Guis = Player.PlayerGui:GetGuiObjectsAtPosition(currentPointerPosVector2.X, currentPointerPosVector2.Y)
                            local Sorted = Utils.SortTable(v_active.Clippings, Guis, v_active.Object)
                            if Sorted then v_active.Clipped = Sorted
                            else if not v_active.AutoClip then v_active.Clipped = nil end end

                            if v_active.Snappings then
                                local Closest, ChosenSnap
                                for _, snap in ipairs(v_active.Snappings) do
                                    local CurrentMag = (v_active.Object.AbsolutePosition - snap.AbsolutePosition).Magnitude
                                    if not Closest or CurrentMag < Closest then
                                        Closest = CurrentMag; ChosenSnap = snap;
                                    end
                                end
                                if Closest and (Closest * 0.0264583333) <= 3.5 then v_active.Snap = ChosenSnap
                                else v_active.Snap = nil end
                            end
                        end)
                    end
                end
            end
        end)

        UIS.InputEnded:Connect(function(Input)
            if dragData.isDragging and dragData.inputObject and
               (Input.UserInputType == dragData.inputObject.UserInputType) and
               (  (Input.UserInputType == Enum.UserInputType.MouseButton1 and Input.UserInputState == Enum.UserInputState.End) or
                  (Input.UserInputType == Enum.UserInputType.Touch and Input.TouchId == dragData.inputObject.TouchId and Input.UserInputState == Enum.UserInputState.End)
               )
            then
                if RenderConnection then RenderConnection:Disconnect(); RenderConnection = nil; end

                local v_active_end = dragData.draggedObjectInstance
                if v_active_end then
                    coroutine.wrap(function()
                        if v_active_end.Clipped and (not v_active_end.Snap or Settings.Priority == "Clipping") then
                            local targetPos = v_active_end.Clipped.Position
                            if v_active_end.ResponseTime and v_active_end.ResponseTime > 0 then
                                for i = 1, 10 do RS.RenderStepped:Wait(); v_active_end.Object.Position = v_active_end.Object.Position:Lerp(targetPos, i/10) end
                            else
                                v_active_end.Object.Position = targetPos
                            end
                            v_active_end.Object.Rotation = v_active_end.Clipped.Rotation
                        end
                        if v_active_end.Snap and (not v_active_end.Clipped or Settings.Priority == "Snapping") then
                            local Target_snap = Utils.Snap(v_active_end.Snap, v_active_end.Object, v_active_end._Target) -- Renamed Target
                             if v_active_end.ResponseTime and v_active_end.ResponseTime > 0 then
                                for i = 1, 10 do RS.RenderStepped:Wait(); v_active_end.Object.Position = v_active_end.Object.Position:Lerp(Target_snap, i/10) end
                            else
                                v_active_end.Object.Position = Target_snap
                            end
                            v_active_end.Snap = nil
                        end
                    end)()
                    v_active_end.OldPosition = nil
                    v_active_end.isCurrentlyBeingDragged = false
                end

                dragData.isDragging = false
                dragData.inputObject = nil
                dragData.lastPosition = nil
                dragData.draggedObjectInstance = nil
            end
        end)
        return drag
    end
end

local Draggable = getDragIt()

local function getEffect()
    local module = {}
    local TweenService = game:GetService("TweenService")
    local TI_effect = TweenInfo.new(.4, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

    module.ButtonHoverEffect = function(ui, req)
        local HoverEvent = Instance.new("BindableEvent")
        local conns = {}
        local hovering = false
        local touchActiveId = nil

        local function StartHover()
            if hovering then return end
            hovering = true
            if ui:FindFirstChild("HoverFrame") then
                TweenService:Create(ui.HoverFrame, TI_effect, { BackgroundTransparency = .5 }):Play()
            end
            HoverEvent:Fire()
        end

        local function EndHover()
            if not hovering then return end
            hovering = false
            touchActiveId = nil
            if ui:FindFirstChild("HoverFrame") then
                TweenService:Create(ui.HoverFrame, TI_effect, { BackgroundTransparency = 1 }):Play()
            end
        end

        if ui.MouseEnter and ui.MouseLeave and ui.TouchBegan and ui.TouchEnded and ui.TouchMoved then
            table.insert(conns, ui.MouseEnter:Connect(function()
                if req and req() == false then return end
                StartHover()
            end))
            table.insert(conns, ui.MouseLeave:Connect(function()
                if req and req() == false then return end
                EndHover()
            end))

            table.insert(conns, ui.TouchBegan:Connect(function(input)
                if touchActiveId then return end
                if req and req() == false then return end
                touchActiveId = input.TouchId
                StartHover()
            end))

            table.insert(conns, ui.TouchEnded:Connect(function(input)
                if input.TouchId ~= touchActiveId then return end
                if req and req() == false then return end
                EndHover()
            end))

            table.insert(conns, ui.TouchMoved:Connect(function(input)
                if input.TouchId ~= touchActiveId or not hovering then return end
                if req and req() == false then return end

                local guiObject = input.TouchedGuis
                local isStillOver = false
                for _,g_obj in ipairs(guiObject) do
                    if g_obj == ui then
                        isStillOver = true
                        break
                    end
                end
                if not isStillOver then
                    EndHover()
                end
            end))
        else
            warn("ButtonHoverEffect: Одно или несколько событий (MouseEnter, MouseLeave, TouchBegan, TouchEnded, TouchMoved) не найдены для " .. ui:GetFullName() .. ". Эффекты наведения могут не работать корректно для всех типов ввода.")
        end


        return {
            Event = HoverEvent.Event,
            Disconnect = function()
                for _, v_conn in ipairs(conns) do v_conn:Disconnect() end
                EndHover()
            end
        }
    end

    module.ButtonClickEffect = function(ui, req)
        local ClickEvent = Instance.new("BindableEvent")
        local conns = {}
        local originalTransparency = ui.BackgroundTransparency
        local touchDownId = nil

        local function StartClickAnim()
            TweenService:Create(ui, TI_effect, { BackgroundTransparency = math.max(0, originalTransparency - 0.3) }):Play()
        end
        local function EndClickAnim(fireEvent, inputObj)
            TweenService:Create(ui, TI_effect, { BackgroundTransparency = originalTransparency }):Play()
            if fireEvent then
                if req and req(inputObj) == false then return end
                ClickEvent:Fire(inputObj)
            end
        end

        if ui.InputBegan and ui.InputEnded and ui.MouseLeave and ui.TouchMoved then
            table.insert(conns, ui.InputBegan:Connect(function(input, gp)
                if gp then return end
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    if req and req(input) == false then return end
                    StartClickAnim()
                elseif input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin then
                     if touchDownId then return end
                     if req and req(input) == false then return end
                     touchDownId = input.TouchId
                     StartClickAnim()
                end
            end))

            table.insert(conns, ui.InputEnded:Connect(function(input, gp)
                if gp then return end
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    EndClickAnim(true, input)
                elseif input.UserInputType == Enum.UserInputType.Touch and input.TouchId == touchDownId then
                    touchDownId = nil
                    EndClickAnim(true, input)
                end
            end))

            table.insert(conns, ui.MouseLeave:Connect(function()
                EndClickAnim(false)
            end))

            table.insert(conns, ui.TouchMoved:Connect(function(input)
                if input.TouchId ~= touchDownId then return end
                local guiObject = input.TouchedGuis
                local isStillOver = false
                for _,g_obj in ipairs(guiObject) do
                    if g_obj == ui then
                        isStillOver = true
                        break
                    end
                end
                if not isStillOver then
                    touchDownId = nil
                    EndClickAnim(false)
                end
            end))
        else
             warn("ButtonClickEffect: Одно или несколько событий (InputBegan, InputEnded, MouseLeave, TouchMoved) не найдены для " .. ui:GetFullName() .. ". Эффекты клика могут не работать корректно для всех типов ввода.")
        end


        return {
            Event = ClickEvent.Event,
            Disconnect = function()
                for _, v_conn in ipairs(conns) do v_conn:Disconnect() end
                EndClickAnim(false)
            end
        }
    end

    return module
end

local EffectLib = getEffect()
local CircleClick = function(Button, InputObject)
    local circle = Instance.new("Frame");
    Instance.new("UICorner", circle);

    circle.UICorner.CornerRadius = UDim.new(1, 0);
    circle.AnchorPoint = Vector2.new(0.5, 0.5);
    circle.BackgroundColor3 = Color3.fromRGB(0,0,0);

    local clickPosX, clickPosY
    if InputObject and InputObject.Position then
        clickPosX = InputObject.Position.X
        clickPosY = InputObject.Position.Y
    else
        local mouse = game.Players.LocalPlayer:GetMouse()
        clickPosX = mouse.X
        clickPosY = mouse.Y
    end

    circle.Position = UDim2.new(0, clickPosX - Button.AbsolutePosition.X, 0, clickPosY - Button.AbsolutePosition.Y);
    circle.Size = UDim2.new(0, 1, 0, 1);
    circle.Transparency = .8;
    circle.ZIndex = 999

    circle.Parent = Button;

    local finalGoal = {};
    finalGoal.Size = UDim2.new(0, (Button.AbsoluteSize.X), 0, (Button.AbsoluteSize.X));
    finalGoal.Transparency = 1;

    game.Debris:AddItem(circle,.4)

    local tween = game:GetService("TweenService"):Create(circle, TweenInfo.new(.4, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), finalGoal);
    tween:Play();
end

local function getLayoutOrder(UI)
    local layoutTable = {0}

    for i, v_child in pairs(UI:GetChildren()) do
        if v_child:IsA("GuiObject") then
            table.insert(layoutTable, v_child.LayoutOrder)
        end
    end

    return math.max(unpack(layoutTable)) + 1
end

local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

local TweenService = game:GetService("TweenService")
local TI = TweenInfo.new(.4, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

local UILibNames = {
    "Window",
    "Category",
    "Button",
    "Section"
}

for i, v_name in pairs(UILibNames) do
    UILibrary[v_name] = {}
    UILibrary[v_name].__index = UILibrary[v_name]
end

function UILibrary.new(gameName, userId, rank)
    local GUI = Instance.new("ScreenGui")
    GUI.Name = HttpService:GenerateGUID(false)
    GUI.Parent =
        RunService:IsStudio() == false and game:GetService("CoreGui") or LocalPlayer:WaitForChild("PlayerGui")
    GUI.ResetOnSpawn = false
    GUI.ZIndexBehavior = Enum.ZIndexBehavior.Global

    local window = objectGenerator.new("Window")
    window.Parent = GUI


    local FrameDraggable = Instance.new("Frame")
    FrameDraggable.BackgroundTransparency = 1
    FrameDraggable.Size = UDim2.fromScale(2, 2)

    FrameDraggable.AnchorPoint = Vector2.new(0.5, 0.5)
    FrameDraggable.Position = UDim2.fromScale(.5, .5)

    local AspectRatio = Instance.new("UIAspectRatioConstraint", FrameDraggable)
    AspectRatio.AspectRatio = 1.2

    FrameDraggable.Parent = window.MainUI.Sidebar.ContentHolder.Cheats.Logo
    FrameDraggable.ZIndex = 300

    local Drag = Draggable.Drag(window.MainUI, FrameDraggable)

    window.Watermark.Text = ("visuals | %s | %s"):format(userId, gameName)
    local userinfo = window.MainUI.Sidebar.ContentHolder.UserInfo.Content
    userinfo.Rank.Text = rank
    userinfo.Title.Text = userId

    return setmetatable(
        {
            UI = {},
            windowInfo = {
                gameName = gameName,
                userId = userId,
                rank = rank
            },
            currentSelection = nil,
            currentCategorySelection = nil,
            currentTab = nil,
            MainUI = window
        },
        UILibrary.Window
    )
end

function UILibrary.Window:setAnimSpeed(val)
    TI = TweenInfo.new(.4 / (val / 100), Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
end

function UILibrary.Window:Notification(sett)
    local Notif = objectGenerator.new("Notification").Main

    Notif.Size = UDim2.new(1, 0, 1, -5)
    if Notif:FindFirstChildOfClass("UIAspectRatioConstraint") then
        Notif:FindFirstChildOfClass("UIAspectRatioConstraint"):Destroy()
    end

    local ui = self.MainUI.Notifications

    Notif.Content.Text.Title.Text = sett.Title
    Notif.Content.Text.Desc.Text = sett.Desc

    local layout = getLayoutOrder(ui)

    Notif.LayoutOrder = layout

    Notif.Notification.BackgroundTransparency = 0
    Notif.Parent.Size = UDim2.fromScale(1, 0)

    Notif.Parent.Parent = ui

    wait(.02)

    TweenService:Create(
        Notif.Parent,
        TI,
        {
            Size = UDim2.new(1, 0, .1, 5)
        }
    ):Play()

    wait(.2)

    TweenService:Create(
        Notif.Notification,
        TI,
        {
            BackgroundTransparency = 1
        }
    ):Play()

    local connections = {}
    local isOpen = true

    local function expire()
        isOpen = false

        for i_conn, v_conn in pairs(connections) do
            v_conn:Disconnect()
        end
        connections = {}

        TweenService:Create(
            Notif.Notification,
            TI,
            {
                BackgroundTransparency = 0
            }
        ):Play()

        TweenService:Create(
            Notif,
            TweenInfo.new(.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
            {
                Position = UDim2.fromScale(2, 0)
            }
        ):Play()

        task.delay(
            .3,
            function()
                TweenService:Create(
                    Notif.Parent,
                    TweenInfo.new(.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
                    {
                        Size = UDim2.fromScale(0, 0)
                    }
                ):Play()

                local parent = Notif.Parent
                if parent then
                    parent:ClearAllChildren()
                    task.delay(.3, function() if parent and parent.Parent then parent:Destroy() end end)
                end
            end
        )

        for i_desc, v_desc in pairs(Notif:GetDescendants()) do
            if v_desc:IsA("ImageLabel") or v_desc:IsA("ImageButton") then
                TweenService:Create(v_desc, TI, { ImageTransparency = 1 }):Play()
            elseif v_desc:IsA("TextLabel") then
                TweenService:Create(v_desc, TI, { TextTransparency = 1 }):Play()
            end
        end
    end


    if sett.expire then
        task.delay(
            sett.expire,
            function()
                if isOpen then
                    expire()
                end
            end
        )
    end

    if Notif.Content.Buttons.InputBegan and Notif.Content.Buttons.InputEnded then
        table.insert(connections, Notif.Content.Buttons.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                TweenService:Create(Notif.Content.Buttons.Close, TI, { ImageColor3 = Color3.fromRGB(181, 181, 181) }):Play()
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 or (input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin) then
                expire()
            end
        end))

        table.insert(connections, Notif.Content.Buttons.InputEnded:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                TweenService:Create(Notif.Content.Buttons.Close, TI, { ImageColor3 = Color3.fromRGB(255, 255, 255) }):Play()
            end
        end))
    else
        warn("Notification Buttons events not found for: " .. Notif.Content.Buttons:GetFullName())
    end
end

function UILibrary.Window:Prompt(sett)
    local Notif = objectGenerator.new("Prompt").Main

    Notif.Size = UDim2.new(1, 0, 1, -5)
    if Notif:FindFirstChildOfClass("UIAspectRatioConstraint") then
       Notif:FindFirstChildOfClass("UIAspectRatioConstraint"):Destroy()
    end

    local ui = self.MainUI.Notifications

    Notif.Content.Text.Title.Text = sett.Title
    Notif.Content.Text.Desc.Text = sett.Desc

    local layout = getLayoutOrder(ui)

    Notif.LayoutOrder = layout

    Notif.Notification.BackgroundTransparency = 0
    Notif.Parent.Size = UDim2.fromScale(1, 0)

    Notif.Parent.Parent = ui

    wait(.02)

    TweenService:Create(
        Notif.Parent,
        TI,
        {
            Size = UDim2.new(1, 0, .1, 5)
        }
    ):Play()

    wait(.2)

    TweenService:Create(
        Notif.Notification,
        TI,
        {
            BackgroundTransparency = 1
        }
    ):Play()

    local connections = {}
    local isOpen = true

    local selection = nil
    local bindable = Instance.new("BindableEvent")

    local function expire()
        isOpen = false

        bindable:Fire()

        for i_conn, v_conn in pairs(connections) do
            v_conn:Disconnect()
        end
        connections = {}

        TweenService:Create(
            Notif.Notification,
            TI,
            {
                BackgroundTransparency = 0
            }
        ):Play()

        TweenService:Create(
            Notif,
            TweenInfo.new(.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
            {
                Position = UDim2.fromScale(2, 0)
            }
        ):Play()

        task.delay(
            .3,
            function()
                TweenService:Create(
                    Notif.Parent,
                    TweenInfo.new(.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
                    {
                        Size = UDim2.fromScale(0, 0)
                    }
                ):Play()

                local parent = Notif.Parent
                if parent then
                    parent:ClearAllChildren()
                    task.delay(.3, function() if parent and parent.Parent then parent:Destroy() end end)
                end
            end
        )

        for i_desc, v_desc in pairs(Notif:GetDescendants()) do
            if v_desc:IsA("ImageLabel") or v_desc:IsA("ImageButton") then
                TweenService:Create(v_desc, TI, { ImageTransparency = 1 }):Play()
            elseif v_desc:IsA("TextLabel") then
                TweenService:Create(v_desc, TI, { TextTransparency = 1 }):Play()
            end
        end
    end

    local function extraHitbox(obj, downOrUp)
        local FrameHitbox = Instance.new("Frame")
        FrameHitbox.Size = UDim2.fromScale(1, .35)
        FrameHitbox.BackgroundTransparency = 1

        obj.Parent = FrameHitbox
        FrameHitbox.Name = obj.Name
        obj.Name = "Button"

        obj.Position = UDim2.fromScale(.5, .5 - (.2 / downOrUp))

        return FrameHitbox
    end

    local ParentButtons = Notif.Content.Buttons

    local CloseButton = extraHitbox(Notif.Content.Buttons.Close, 1)
    CloseButton.LayoutOrder = 1

    local AcceptButton = extraHitbox(Notif.Content.Buttons.Accept, -1)

    CloseButton.Parent = ParentButtons
    AcceptButton.Parent = ParentButtons

    if CloseButton.InputBegan and CloseButton.InputEnded then
        table.insert(connections, CloseButton.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                TweenService:Create(CloseButton.Button, TI, { ImageColor3 = Color3.fromRGB(181, 181, 181) }):Play()
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 or (input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin) then
                expire()
            end
        end))

        table.insert(connections, CloseButton.InputEnded:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                TweenService:Create(CloseButton.Button, TI, { ImageColor3 = Color3.fromRGB(255, 255, 255) }):Play()
            end
        end))
    else
        warn("Prompt CloseButton events not found for: " .. CloseButton:GetFullName())
    end

    if AcceptButton.InputBegan and AcceptButton.InputEnded then
        table.insert(connections, AcceptButton.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                TweenService:Create(AcceptButton.Button, TI, { ImageColor3 = Color3.fromRGB(181, 181, 181) }):Play()
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 or (input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin) then
                selection = true
                expire()
            end
        end))

        table.insert(connections, AcceptButton.InputEnded:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                TweenService:Create(AcceptButton.Button, TI, { ImageColor3 = Color3.fromRGB(255, 255, 255) }):Play()
            end
        end))
    else
        warn("Prompt AcceptButton events not found for: " .. AcceptButton:GetFullName())
    end


    bindable.Event:Wait()
    return selection
end

function UILibrary.Window:ChangeCategory(new)
    local catFolder = self.MainUI.MainUI.Sidebar.ContentHolder.Cheats.CheatHolder
    local Object = catFolder:FindFirstChild(new)

    if Object and self.currentSelection ~= Object then
        if self.currentSelection then
            TweenService:Create(
                self.currentSelection.Content.Image,
                TI,
                {
                    ImageColor3 = Color3.fromRGB(90, 90, 90)
                }
            ):Play()

            TweenService:Create(
                self.currentSelection.Content.Title,
                TI,
                {
                    TextColor3 = Color3.fromRGB(90, 90, 90)
                }
            ):Play()

            TweenService:Create(
                self.currentSelection.HoverFrame,
                TI,
                {
                    BackgroundTransparency = 1
                }
            ):Play()

            TweenService:Create(
                self.MainUI.MainUI.Sidebar.Sidebar2[self.currentSelection.Name],
                TI,
                {
                    Position = UDim2.fromScale(1, 0)
                }
            ):Play()
        end

        TweenService:Create(
            Object.Content.Image,
            TI,
            {
                ImageColor3 = Color3.fromRGB(255, 255, 255)
            }
        ):Play()

        TweenService:Create(
            Object.Content.Title,
            TI,
            {
                TextColor3 = Color3.fromRGB(255, 255, 255)
            }
        ):Play()

        TweenService:Create(
            Object.HoverFrame,
            TI,
            {
                BackgroundTransparency = .3
            }
        ):Play()

        TweenService:Create(
            self.MainUI.MainUI.Sidebar.Sidebar2[Object.Name],
            TI,
            {
                Position = UDim2.fromScale(0, 0)
            }
        ):Play()

        self.currentSelection = Object

        local firstChild = nil

        for i, v_child in pairs(self.MainUI.MainUI.Sidebar.Sidebar2[Object.Name].Bar2Holder:GetChildren()) do
            if v_child:IsA("GuiObject") then
                firstChild = v_child
                break
            end
        end

        if firstChild then
            self:ChangeCategorySelection(firstChild.Name)
        end
    end
end

function UILibrary.Window:ChangeCategorySelection(name)
    local catFolder = self.MainUI.MainUI.Sidebar.Sidebar2[self.currentSelection.Name].Bar2Holder
    local Object = catFolder:FindFirstChild(name)

    if Object and self.currentCategorySelection ~= Object then
        if self.currentCategorySelection then
            TweenService:Create(
                self.currentCategorySelection.InnerContent.Image,
                TI,
                {
                    ImageColor3 = Color3.fromRGB(90, 90, 90)
                }
            ):Play()

            TweenService:Create(
                self.currentCategorySelection.InnerContent.Title,
                TI,
                {
                    TextColor3 = Color3.fromRGB(90, 90, 90)
                }
            ):Play()

            TweenService:Create(
                self.currentCategorySelection.HoverFrame,
                TI,
                {
                    BackgroundTransparency = 1
                }
            ):Play()

            TweenService:Create(
                self.currentCategorySelection.SelectionShadow,
                TI,
                {
                    BackgroundTransparency = 1
                }
            ):Play()

            TweenService:Create(
                self.currentTab,
                TI,
                {
                    Position = UDim2.fromScale(0, 1)
                }
            ):Play()
        end

        TweenService:Create(
            Object.InnerContent.Image,
            TI,
            {
                ImageColor3 = Color3.fromRGB(255, 255, 255)
            }
        ):Play()

        TweenService:Create(
            Object.InnerContent.Title,
            TI,
            {
                TextColor3 = Color3.fromRGB(255, 255, 255)
            }
        ):Play()

        TweenService:Create(
            Object.HoverFrame,
            TI,
            {
                BackgroundTransparency = .3
            }
        ):Play()

        TweenService:Create(
            Object.SelectionShadow,
            TI,
            {
                BackgroundTransparency = .6
            }
        ):Play()

        local tab = self.MainUI.MainUI.Content:FindFirstChild(name)

        if tab then
            TweenService:Create(
                tab,
                TI,
                {
                    Position = UDim2.fromScale(0, 0)
                }
            ):Play()
        end

        self.currentTab = tab
        self.currentCategorySelection = Object
    end
end

function UILibrary.Window:Category(name, icon)
    local catFolder = self.MainUI.MainUI.Sidebar.ContentHolder.Cheats.CheatHolder
    local category = objectGenerator.new("Category")

    if not (category:IsA("GuiButton") or category:IsA("TextButton") or category:IsA("ImageButton")) then
        warn("UILibrary.Window:Category - ОШИБКА: 'category' ("..category.Name..") не является интерактивным Gui элементом. Эффекты могут не работать. Проверьте шаблон 'Category' в objectGenerator.")
    end

    category.Content.Title.Text = name
    category.Content.Image.Image = icon

    self.UI[name] = {}

    category.Name = name
    category.Parent = catFolder
    category.LayoutOrder = getLayoutOrder(catFolder)

    local contentHolder = objectGenerator.new("CategoryContent")
    contentHolder.Name = name
    contentHolder.Visible = true
    contentHolder.Parent = self.MainUI.MainUI.Sidebar.Sidebar2

    local Hover = EffectLib.ButtonHoverEffect(category, function()
        return self.currentSelection ~= category
    end)

    local Click = EffectLib.ButtonClickEffect(category)

    Click.Event:Connect(function(inputObj)
        CircleClick(category, inputObj)
        self:ChangeCategory(name)
    end)

    if self.currentSelection == nil then
        self:ChangeCategory(name)
    end

    return setmetatable({
        Effects = {
            Hover = Hover,
            Click = Click
        },
        oldSelf = self,
        categoryUI = category,
        contentHolder = contentHolder
    }, UILibrary.Category)
end

function UILibrary.Category:Button(name, icon)
    local contentholder = self.contentHolder
    local button = objectGenerator.new("CategoryButton")

    if not (button:IsA("GuiButton") or button:IsA("TextButton") or button:IsA("ImageButton")) then
        warn("UILibrary.Category:Button - ОШИБКА: 'button' ("..button.Name..") не является интерактивным Gui элементом. Эффекты могут не работать. Проверьте шаблон 'CategoryButton' в objectGenerator.")
    end

    button.InnerContent.Image.Image = icon
    button.InnerContent.Title.Text = name

    button.Parent = self.contentHolder.Bar2Holder
    button.LayoutOrder = getLayoutOrder(self.contentHolder.Bar2Holder)
    button.Name = name

    local totalCount = 0
    for i_child, v_child in pairs(self.contentHolder.Bar2Holder:GetChildren()) do
        if v_child:IsA("GuiObject") then
            totalCount = totalCount + 1
        end
    end

    if totalCount == 0 then totalCount = 1 end

    for i_child, v_child in pairs(self.contentHolder.Bar2Holder:GetChildren()) do
        if v_child:IsA("GuiObject") then
            v_child.Size = UDim2.fromScale(1, 1 / totalCount)
        end
    end
    button.Size = UDim2.fromScale(1, 1 / totalCount)


    self.oldSelf.UI[self.categoryUI.Name][name] = {}

    local CategoryFrame = objectGenerator.new("CategoryFrame")
    CategoryFrame.Name = name
    CategoryFrame.Parent = self.oldSelf.MainUI.MainUI.Content
    CategoryFrame.Visible = true

    local Hover = EffectLib.ButtonHoverEffect(button, function()
        return self.oldSelf.currentCategorySelection ~= button
    end)

    local Click = EffectLib.ButtonClickEffect(button)

    Click.Event:Connect(function(inputObj)
        CircleClick(button, inputObj)
        if self.oldSelf.currentSelection.Name == self.categoryUI.Name then
            self.oldSelf:ChangeCategorySelection(name)
        end
    end)

    if self.oldSelf.currentCategorySelection == nil and self.oldSelf.currentSelection.Name == self.categoryUI.Name then
        self.oldSelf:ChangeCategorySelection(name)
    end

    return setmetatable({
        Effects = {
            Hover = Hover,
            Click = Click
        },
        oldSelf = self,
        CategoryName = self.categoryUI.Name,
        SectionName = name,
        CategoryFrame = CategoryFrame
    }, UILibrary.Button)
end
-- Блок function UILibrary.Button:Section(name, side, options) и далее до конца файла не изменился
-- по сравнению с предыдущим полным ответом, поэтому я его здесь не дублирую для краткости.
-- Убедитесь, что вы используете его из предыдущего полного ответа.

-- ... (Код для UILibrary.Button:Section, generateCheatBase, setupEffects, UILibrary.Section:Button, Checkbox, Toggle, Textbox, Keybind, ColorPicker, Slider, Dropdown, Label)

function UILibrary.Button:Section(name, side, options)
    local SectionInstance = objectGenerator.new("Section")

    if not SectionInstance then
        error(string.format("UILibrary.Button:Section - КРИТИЧЕСКАЯ ОШИБКА: objectGenerator.new(\"Section\") вернул nil. Невозможно создать секцию '%s'.", tostring(name)))
        return
    end

    local Section = SectionInstance
    Section.Name = name

    local BorderFrame = Section:FindFirstChild("Border")
    if not BorderFrame then
        error(string.format("UILibrary.Button:Section - КРИТИЧЕСКАЯ ОШИБКА: У созданного экземпляра Section ('%s') отсутствует дочерний элемент 'Border'.", name))
        Section:Destroy()
        return
    end

    BorderFrame.SectionTitle.Text = name

    local minPixelHeight = options and options.MinHeight or 0
    local maxPixelHeight = options and options.MaxHeight or math.huge

    local oldSizeConstraint = Section:FindFirstChild("HeightConstraint")
    if oldSizeConstraint then
        oldSizeConstraint:Destroy()
    end

    local SECTION_VERTICAL_PADDING = 20

    local function updateSectionHeight()
        local border = Section:FindFirstChild("Border")
        if not border then return end
        local content = border:FindFirstChild("Content")
        if not content then return end
        local listLayout = content:FindFirstChild("UIListLayout")
        if not listLayout then return end

        local contentHeight = listLayout.AbsoluteContentSize.Y
        local desiredHeight = contentHeight + SECTION_VERTICAL_PADDING
        local clampedHeight = math.clamp(desiredHeight, minPixelHeight, maxPixelHeight)

        local success, err = pcall(function()
            Section.Size = UDim2.new(1, 0, 0, clampedHeight)
        end)
        if not success then
            warn(string.format("UILibrary.Button:Section.updateSectionHeight - Ошибка при установке Section.Size для '%s': %s", name, tostring(err)))
        end
    end

    task.defer(function()
        if not Section or not Section.Parent then return end

        local border = Section:FindFirstChild("Border")
        if not border then return end
        local content = border:FindFirstChild("Content")
        if not content then return end
        local listLayout = content:FindFirstChild("UIListLayout")

        if content then
            content.ChildAdded:Connect(updateSectionHeight)
            content.ChildRemoved:Connect(updateSectionHeight)
        end

        if listLayout then
             listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateSectionHeight)
        else
             warn("UILibrary.Button:Section (defer) - UIListLayout не найден в Section.Border.Content для секции: " .. name)
        end
        updateSectionHeight()
    end)

    Section.Parent = self.oldSelf.oldSelf.MainUI.MainUI.Content[self.SectionName][side]
    Section.LayoutOrder = getLayoutOrder(self.oldSelf.oldSelf.MainUI.MainUI.Content[self.SectionName][side])

    self.oldSelf.oldSelf.UI[self.oldSelf.categoryUI.Name][self.SectionName][name] = {}

    return setmetatable(
        {
            MainSelf = self.oldSelf.oldSelf,
            oldSelf = self,
            Section = Section
        },
        UILibrary.Section
    )
end

local cheatInfo = {
    ["Button"] = {
        FullSize = true
    },
    ["Checkbox"] = {
        TextSize = UDim2.fromScale(.2, 1)
    },
    ["Textbox"] = {
        TextSize = UDim2.fromScale(.4, 1),
        FullSize = true
    },
    ["Dropdown"] = {
        FullSize = true
    },
    ["Slider"] = {
        TextSize = UDim2.fromScale(.45, 1)
    },
    ["Toggle"] = {
        TextSize = UDim2.fromScale(.5, 1)
    }
}

local function generateCheatBase(Cheat, sett)
    local cheatBase = objectGenerator.new("CheatBase")

    local cheatinfo = cheatInfo[Cheat]
    local supportsFullSize = cheatinfo ~= nil and cheatinfo.FullSize or false

    local Size = supportsFullSize and UDim2.fromScale(1, 1) or UDim2.fromScale(.5, 1)

    if sett.Title then
        if sett.Description then
            cheatBase.Content.Text.Text.Text = sett.Title
            cheatBase.Content.Text.Text.Desc.Text = sett.Description

            cheatBase.Content.Text.Text.Desc.Visible = true
            cheatBase.Content.Text.Text.Visible = true
        else
            cheatBase.Content.Text.Text.Text = sett.Title
            cheatBase.Content.Text.Text.Size = UDim2.fromScale(.9, 1)
            cheatBase.Content.Text.Text.Position = UDim2.fromScale(.5, .5)
            cheatBase.Content.Text.Text.Visible = true
        end

        if cheatinfo and cheatinfo.TextSize then
            Size = cheatinfo.TextSize
        else
            Size = UDim2.fromScale(.5, 1)
        end
    end

    local XSize = 1 - Size.X.Scale

    cheatBase.Content.ElementContent.Size = Size
    cheatBase.Content.Text.Size = UDim2.fromScale(XSize, 1)

    local ContentInstance = objectGenerator.new("Cheat", Cheat) -- Renamed Content

    if ContentInstance then
        ContentInstance.Parent = cheatBase.Content.ElementContent
    end

    return cheatBase
end

local function setupEffects(ui, hover)
    local ClickEvent = Instance.new("BindableEvent")
    local uiTweenType = (hover:IsA("ImageLabel") or hover:IsA("ImageButton")) and "ImageTransparency" or "BackgroundTransparency"
    local originalTransparency = hover[uiTweenType]
    local touchActiveId = nil

    local function constructTweenInfo(value)
        local props = {}
        props[uiTweenType] = value
        return props
    end

    if ui:IsA("GuiButton") or ui:IsA("TextButton") or ui:IsA("ImageButton") then
        ui.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                TweenService:Create(hover, TI, constructTweenInfo(originalTransparency - 0.5)):Play()
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                TweenService:Create(hover, TI, constructTweenInfo(originalTransparency - 0.8)):Play()
            elseif input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin then
                if touchActiveId then return end
                touchActiveId = input.TouchId
                TweenService:Create(hover, TI, constructTweenInfo(originalTransparency - 0.8)):Play()
            end
        end)

        ui.InputEnded:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                TweenService:Create(hover, TI, constructTweenInfo(originalTransparency)):Play()
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                TweenService:Create(hover, TI, constructTweenInfo(originalTransparency - 0.5)):Play()
                ClickEvent:Fire(input)
            elseif input.UserInputType == Enum.UserInputType.Touch and input.TouchId == touchActiveId then
                touchActiveId = nil
                TweenService:Create(hover, TI, constructTweenInfo(originalTransparency - 0.5)):Play()
                ClickEvent:Fire(input)
            end
        end)

        ui.MouseLeave:Connect(function()
            TweenService:Create(hover, TI, constructTweenInfo(originalTransparency)):Play()
        end)

        ui.TouchMoved:Connect(function(input)
            if input.TouchId ~= touchActiveId then return end
            local guiObject = input.TouchedGuis
            local isStillOver = false
            for _,g_obj in ipairs(guiObject) do
                if g_obj == ui then
                    isStillOver = true
                    break
                end
            end
            if not isStillOver then
                touchActiveId = nil
                TweenService:Create(hover, TI, constructTweenInfo(originalTransparency)):Play()
            end
        end)
    else
         warn("setupEffects: 'ui' ("..ui:GetFullName()..") is not a GuiButton, TextButton, or ImageButton. Events like InputBegan may not be available.")
    end


    return ClickEvent.Event
end

function UILibrary.Section:Button(sett, callback)
    local functions = {}
    functions.__index = functions

    local cheatBase = generateCheatBase("Button", sett)
    cheatBase.Parent = self.Section.Border.Content
    cheatBase.LayoutOrder = getLayoutOrder(self.Section.Border.Content)

    local element = cheatBase.Content.ElementContent.Button

    setupEffects(element, element.HoverFrame):Connect(
        function(inputObj)
            callback(inputObj)
        end
    )

    element.Text.Text = sett.ButtonName

    local meta =
        setmetatable(
        {
            element = element,
            UI = cheatBase
        },
        functions
    )

    self.oldSelf.oldSelf.oldSelf.UI[self.oldSelf.oldSelf.categoryUI.Name][self.oldSelf.SectionName][
            self.Section.Name
        ][sett.Title] = meta

    return meta
end

function UILibrary.Section:Checkbox(sett, callback)
    local functions = {}
    functions.__index = functions

    local cheatBase = generateCheatBase("Checkbox", sett)
    cheatBase.Parent = self.Section.Border.Content
    cheatBase.LayoutOrder = getLayoutOrder(self.Section.Border.Content)

    local element = cheatBase.Content.ElementContent.Checkbox

    local toggleEnabled = false

    functions.setValue = function(new)
        toggleEnabled = new

        if new then
            TweenService:Create(
                element.Selection,
                TI,
                {
                    Size = UDim2.fromScale(.85, .85),
                    BackgroundTransparency = 0
                }
            ):Play()
        else
            TweenService:Create(
                element.Selection,
                TI,
                {
                    Size = UDim2.fromScale(0.5, 0.5),
                    BackgroundTransparency = 1.1
                }
            ):Play()
        end

        callback(toggleEnabled)
    end

    functions.getValue = function()
        return toggleEnabled
    end

    setupEffects(element, element.HoverFrame):Connect(
        function()
            functions.setValue(not toggleEnabled)
        end
    )

    if sett.Default then
        functions.setValue(sett.Default)
    end

    local meta =
        setmetatable(
        {
            element = element,
            UI = cheatBase
        },
        functions
    )

    self.oldSelf.oldSelf.oldSelf.UI[self.oldSelf.oldSelf.categoryUI.Name][self.oldSelf.SectionName][
            self.Section.Name
        ][sett.Title] = meta

    return meta
end

function UILibrary.Section:Toggle(sett, callback)
    local functions = {}
    functions.__index = functions

    local cheatBase = generateCheatBase("Toggle", sett)
    cheatBase.Parent = self.Section.Border.Content
    cheatBase.LayoutOrder = getLayoutOrder(self.Section.Border.Content)

    local element = cheatBase.Content.ElementContent.Toggle

    local toggleEnabled = false

    functions.setValue = function(new)
        toggleEnabled = new

        if new then
            TweenService:Create(
                element.Content.Frame,
                TI,
                {
                    Position = UDim2.fromScale(.8, .5)
                }
            ):Play()

            TweenService:Create(
                element,
                TI,
                {
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                }
            ):Play()
        else
            TweenService:Create(
                element.Content.Frame,
                TI,
                {
                    Position = UDim2.fromScale(.2, .5)
                }
            ):Play()

            TweenService:Create(
                element,
                TI,
                {
                    BackgroundColor3 = Color3.fromRGB(25, 25, 25)
                }
            ):Play()
        end

        callback(toggleEnabled)
    end

    functions.getValue = function()
        return toggleEnabled
    end

    setupEffects(element, element.HoverFrame):Connect(
        function()
            functions.setValue(not toggleEnabled)
        end
    )

    if sett.Default then
        functions.setValue(sett.Default)
    end

    local meta =
        setmetatable(
        {
            element = element,
            UI = cheatBase
        },
        functions
    )

    self.oldSelf.oldSelf.oldSelf.UI[self.oldSelf.oldSelf.categoryUI.Name][self.oldSelf.SectionName][
            self.Section.Name
        ][sett.Title] = meta

    return meta
end

function UILibrary.Section:Textbox(sett, callback)
    local functions = {}
    functions.__index = functions

    local cheatBase = generateCheatBase("Textbox", sett)
    cheatBase.Parent = self.Section.Border.Content
    cheatBase.LayoutOrder = getLayoutOrder(self.Section.Border.Content)

    local element = cheatBase.Content.ElementContent.Textbox

    local function updateSize()
        if element.Parent and element.Parent.AbsoluteSize.X > 0 then
            local textBounds = math.clamp(element.Text.TextBounds.X, 10, element.Parent.AbsoluteSize.X) + 20
            TweenService:Create(
                element,
                TI,
                {
                    Size = UDim2.fromScale(textBounds / element.Parent.AbsoluteSize.X, 1)
                }
            ):Play()
        end
    end

    functions.setValue = function(new)
        element.Text.Text = new
        updateSize()
        callback(element.Text.Text)
    end

    functions.getValue = function()
        return element.Text.Text
    end

    task.wait()
    updateSize()

    element.Text.Focused:Connect(
        function()
            TweenService:Create(
                element,
                TI,
                {
                    BackgroundColor3 = Color3.fromRGB(17, 17, 17)
                }
            ):Play()

            TweenService:Create(
                element,
                TI,
                {
                    Size = UDim2.fromScale(1, 1)
                }
            ):Play()
        end
    )

    element.Text.FocusLost:Connect(
        function()
            TweenService:Create(
                element,
                TI,
                {
                    BackgroundColor3 = Color3.fromRGB(25, 25, 25)
                }
            ):Play()

            functions.setValue(element.Text.Text)
        end
    )

    if sett.Default then
        functions.setValue(sett.Default)
    end

    local meta =
        setmetatable(
        {
            element = element,
            UI = cheatBase
        },
        functions
    )

    self.oldSelf.oldSelf.oldSelf.UI[self.oldSelf.oldSelf.categoryUI.Name][self.oldSelf.SectionName][
            self.Section.Name
        ][sett.Title] = meta

    return meta
end

local currentKBInfo = {}

function UILibrary.Section:Keybind(sett, callback)
    local functions = {}
    functions.__index = functions

    local cheatBase = generateCheatBase("Keybind", sett)
    cheatBase.Parent = self.Section.Border.Content
    cheatBase.LayoutOrder = getLayoutOrder(self.Section.Border.Content)

    local element = cheatBase.Content.ElementContent.Keybind

    local function updateSize()
        if element.Parent and element.Parent.AbsoluteSize.X > 0 then
            local textBounds = math.clamp(element.Text.TextBounds.X, 10, element.Parent.AbsoluteSize.X) + 20
            TweenService:Create(
                element,
                TI,
                {
                    Size = UDim2.fromScale(textBounds / element.Parent.AbsoluteSize.X, 1)
                }
            ):Play()
        end
    end

    local currentKb = nil
    local keyPressConn = nil

    functions.setValue = function(new)
        element.Text.Text = new.Name
        updateSize()

        currentKb = new

        if keyPressConn then
            keyPressConn:Disconnect()
        end

        currentKBInfo = {}

        keyPressConn =
            UserInputService.InputBegan:Connect(
            function(input, gp)
                if gp then
                    return
                end
                if not currentKb then return end

                if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKb then
                    callback()
                elseif input.UserInputType.Name == currentKb.Name then
                    callback()
                end
            end
        )
    end

    functions.getValue = function()
        return currentKb
    end

    task.wait()
    updateSize()

    local rebinding = false
    local conn

    setupEffects(element, element.HoverFrame):Connect(
        function()
            if rebinding then
                return
            end

            if currentKBInfo.old and currentKBInfo.set ~= functions.setValue then
                return
            end

            rebinding = true

            element.Text.Text = "..."
            updateSize()

            local old = functions.getValue()

            conn =
                UserInputService.InputBegan:Connect(
                function(input, gp)
                    if input.UserInputType == Enum.UserInputType.Keyboard then
                        currentKb = input.KeyCode
                        rebinding = false
                        functions.setValue(currentKb)
                        conn:Disconnect()
                    elseif
                        input.UserInputType == Enum.UserInputType.MouseButton2 or
                            input.UserInputType == Enum.UserInputType.MouseButton1
                        then
                        currentKb = input.UserInputType
                        rebinding = false
                        functions.setValue(currentKb)
                        conn:Disconnect()
                    end
                end
            )

            currentKBInfo.old = old
            currentKBInfo.conn = conn
            currentKBInfo.set = functions.setValue
        end
    )

    if sett.Default then
        functions.setValue(sett.Default)
    end

    local meta =
        setmetatable(
        {
            element = element,
            UI = cheatBase
        },
        functions
    )
    self.oldSelf.oldSelf.oldSelf.UI[self.oldSelf.oldSelf.categoryUI.Name][self.oldSelf.SectionName][
            self.Section.Name
        ][sett.Title] = meta

    return meta
end

function toInteger(color)
    return math.floor(color.r * 255) * 256 ^ 2 + math.floor(color.g * 255) * 256 + math.floor(color.b * 255)
end

function toHex(color)
    local int = toInteger(color)
    local current = int
    local final = ""
    local hexChar = {"A", "B", "C", "D", "E", "F"}
    repeat
        local remainder = current % 16
        local char = tostring(remainder)
        if remainder >= 10 then char = hexChar[1 + remainder - 10] end
        current = math.floor(current / 16)
        final = final .. char
    until current <= 0
    return "#" .. string.reverse(final)
end

function UILibrary.Section:ColorPicker(sett, callback)
    local functions = {}
    functions.__index = functions
    local cheatBase = generateCheatBase("ColorPicker", sett)
    cheatBase.Parent = self.Section.Border.Content
    cheatBase.LayoutOrder = getLayoutOrder(self.Section.Border.Content)
    local element = cheatBase.Content.ElementContent.ColorPicker
    local menuIsOpen = false
    local currentclr = Color3.fromRGB(255, 255, 255)
    functions.setValue = function(clr)
        TweenService:Create(element.Preview, TI, {ImageColor3 = clr}):Play()
        currentclr = clr
        callback(clr)
        element.Text.Label.Text = math.floor(clr.R * 255) .. ", " .. math.floor(clr.G * 255) .. ", " .. math.floor(clr.B * 255)
    end
    functions.getValue = function() return currentclr end
    functions.openMenu = function()
        if menuIsOpen == true then return end
        menuIsOpen = true
        local oldColor
        self.MainSelf.MainUI.MainUI.ColorPickerOverlay.Visible = true
        TweenService:Create(self.MainSelf.MainUI.MainUI.ColorPickerOverlay, TI, {ImageTransparency = .07}):Play()
        TweenService:Create(self.MainSelf.MainUI.MainUI.ColorPickerOverlay.Content, TI, {Position = UDim2.fromScale(.5, 0.5)}):Play()
        local Content = self.MainSelf.MainUI.MainUI.ColorPickerOverlay.Content
        local colourWheel = Content.MainWindow.Wheel
        local darknessSlider = Content.MainWindow.Saturation.Pointer
        local darknessPicker = Content.MainWindow.Saturation
        local function updateWheel()
            local centreOfWheel = Vector2.new(colourWheel.AbsolutePosition.X + (colourWheel.AbsoluteSize.X / 2), colourWheel.AbsolutePosition.Y + (colourWheel.AbsoluteSize.Y / 2))
            local colourPickerCentre = Vector2.new(colourWheel.Pointer.AbsolutePosition.X + (colourWheel.Pointer.AbsoluteSize.X / 2), colourWheel.Pointer.AbsolutePosition.Y + (colourWheel.Pointer.AbsoluteSize.Y / 2))
            local h = (math.pi - math.atan2(colourPickerCentre.Y - centreOfWheel.Y, colourPickerCentre.X - centreOfWheel.X)) / (math.pi * 2)
            local s = (centreOfWheel - colourPickerCentre).Magnitude / (colourWheel.AbsoluteSize.X / 2)
            local v = math.abs((darknessSlider.AbsolutePosition.Y - darknessPicker.AbsolutePosition.Y) / darknessPicker.AbsoluteSize.Y - 1)
            local hsv = Color3.fromHSV(math.clamp(h, 0, 1), math.clamp(s, 0, 1), math.clamp(v, 0, 1))
            return hsv, Color3.fromHSV(math.clamp(h, 0, 1), math.clamp(s, 0, 1), 1)
        end
        local holdingHsv = false
        local holdingSaturation = false
        local activeTouchId = nil
        local connections = {}
        table.insert(connections, Content.MainWindow.Wheel.Hitbox.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then holdingHsv = true
            elseif input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin then
                if activeTouchId then return end; activeTouchId = input.TouchId; holdingHsv = true
            end
        end))
        table.insert(connections, Content.MainWindow.Wheel.Hitbox.InputEnded:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then holdingHsv = false
            elseif input.UserInputType == Enum.UserInputType.Touch and input.TouchId == activeTouchId then holdingHsv = false; activeTouchId = nil end
        end))
        table.insert(connections, Content.MainWindow.Saturation.Hitbox.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then holdingSaturation = true
            elseif input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin then
                 if activeTouchId then return end; activeTouchId = input.TouchId; holdingSaturation = true
            end
        end))
        table.insert(connections, Content.MainWindow.Saturation.Hitbox.InputEnded:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then holdingSaturation = false
            elseif input.UserInputType == Enum.UserInputType.Touch and input.TouchId == activeTouchId then holdingSaturation = false; activeTouchId = nil end
        end))
        table.insert(connections, RunService.RenderStepped:Connect(function()
            local pointerPos_Render
            if activeTouchId then
                local foundTouch = false
                for _, touch_obj in ipairs(UserInputService:GetTouches()) do
                    if touch_obj.TouchId == activeTouchId then pointerPos_Render = Vector2.new(touch_obj.Position.X, touch_obj.Position.Y); foundTouch = true; break end
                end
                if not foundTouch then holdingHsv = false; holdingSaturation = false; activeTouchId = nil; return end
            else
                 local mouseLoc = UserInputService:GetMouseLocation(); pointerPos_Render = Vector2.new(mouseLoc.X, mouseLoc.Y)
            end
            pointerPos_Render = pointerPos_Render - Vector2.new(0, game:GetService("GuiService"):GetGuiInset().Y)
            local centreOfWheel = Vector2.new(colourWheel.AbsolutePosition.X + (colourWheel.AbsoluteSize.X / 2), colourWheel.AbsolutePosition.Y + (colourWheel.AbsoluteSize.Y / 2))
            local distanceFromWheel = (pointerPos_Render - centreOfWheel).Magnitude
            if holdingHsv then
                if distanceFromWheel <= colourWheel.AbsoluteSize.X / 2 then
                    colourWheel.Pointer.Position = UDim2.new(0, pointerPos_Render.X - colourWheel.AbsolutePosition.X, 0, pointerPos_Render.Y - colourWheel.AbsolutePosition.Y)
                end
            end
            if holdingSaturation then
                darknessSlider.Position = UDim2.new(darknessSlider.Position.X.Scale, 0, 0, math.clamp(pointerPos_Render.Y - darknessPicker.AbsolutePosition.Y, 0, darknessPicker.AbsoluteSize.Y))
            end
            local clr, new = updateWheel()
            darknessPicker.ImageColor3 = new
            if clr ~= oldColor then oldColor = clr; Content.ClrDisplay.RGB.Textbox.Text = math.floor(clr.R * 255) .. ", " .. math.floor(clr.G * 255) .. ", " .. math.floor(clr.B * 255); Content.ClrDisplay.Hex.Textbox.Text = toHex(clr) end
        end))
        local function closeMenu()
            for i, v_conn in ipairs(connections) do v_conn:Disconnect() end; connections = {}
            TweenService:Create(self.MainSelf.MainUI.MainUI.ColorPickerOverlay, TI, {ImageTransparency = 1}):Play()
            TweenService:Create(self.MainSelf.MainUI.MainUI.ColorPickerOverlay.Content, TI, {Position = UDim2.fromScale(.5, 1.5)}):Play()
            task.delay(.5, function() if self.MainSelf.MainUI.MainUI.ColorPickerOverlay then self.MainSelf.MainUI.MainUI.ColorPickerOverlay.Visible = false end end)
            menuIsOpen = false
        end
        table.insert(connections, Content.Buttons.Cancel.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 or (input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin) then closeMenu()
            elseif input.UserInputType == Enum.UserInputType.MouseMovement then TweenService:Create(Content.Buttons.Cancel.OtherFill, TI, { ImageColor3 = Color3.fromRGB(150, 69, 71) }):Play() end
        end))
        table.insert(connections, Content.Buttons.Cancel.InputEnded:Connect(function(input, gp)
            if gp then return end; if input.UserInputType == Enum.UserInputType.MouseMovement then TweenService:Create(Content.Buttons.Cancel.OtherFill, TI, { ImageColor3 = Color3.fromRGB(170, 89, 91) }):Play() end
        end))
        table.insert(connections, Content.Buttons.Confirm.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 or (input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin) then
                local actual, clr_confirm = updateWheel(); functions.setValue(actual); closeMenu()
            elseif input.UserInputType == Enum.UserInputType.MouseMovement then TweenService:Create(Content.Buttons.Confirm.OtherFill, TI, { ImageColor3 = Color3.fromRGB(60, 150, 107) }):Play() end
        end))
        table.insert(connections, Content.Buttons.Confirm.InputEnded:Connect(function(input, gp)
            if gp then return end; if input.UserInputType == Enum.UserInputType.MouseMovement then TweenService:Create(Content.Buttons.Confirm.OtherFill, TI, { ImageColor3 = Color3.fromRGB(85, 170, 127) }):Play() end
        end))
    end
    element.Text.Label.Focused:Connect(function() TweenService:Create(element.Text, TI, {ImageColor3 = Color3.fromRGB(20, 20, 20)}):Play() end)
    element.Text.Label.FocusLost:Connect(function()
        TweenService:Create(element.Text, TI, {ImageColor3 = Color3.fromRGB(25, 25, 25)}):Play()
        local split = element.Text.Label.Text:split(","); if #split == 3 then
            local r,g,b = tonumber(split[1]), tonumber(split[2]), tonumber(split[3])
            if r and g and b then functions.setValue(Color3.fromRGB(math.clamp(r,0,255), math.clamp(g,0,255), math.clamp(b,0,255)))
            else element.Text.Label.Text = math.floor(currentclr.R * 255) .. ", " .. math.floor(currentclr.G * 255) .. ", " .. math.floor(currentclr.B * 255) end
        else element.Text.Label.Text = math.floor(currentclr.R * 255) .. ", " .. math.floor(currentclr.G * 255) .. ", " .. math.floor(currentclr.B * 255) end
    end)
    setupEffects(element.Preview, element.Preview.Hover):Connect(function() functions.openMenu() end)
    if sett.Default then functions.setValue(sett.Default) else functions.setValue(Color3.fromRGB(255, 255, 255)) end
    local meta = setmetatable({element = element, UI = cheatBase}, functions)
    self.oldSelf.oldSelf.oldSelf.UI[self.oldSelf.oldSelf.categoryUI.Name][self.oldSelf.SectionName][self.Section.Name][sett.Title] = meta
    return meta
end

function UILibrary.Section:Slider(sett, callback)
    local functions = {}
    functions.__index = functions
    local cheatBase = generateCheatBase("Slider", sett)
    if not cheatBase then warn("UILibrary.Section:Slider - Не удалось создать cheatBase для слайдера: " .. tostring(sett.Title)); return end
    local contentParent = self.Section and self.Section:FindFirstChild("Border") and self.Section.Border:FindFirstChild("Content")
    if not contentParent then warn("UILibrary.Section:Slider - Не найден родительский контейнер для слайдера: " .. tostring(sett.Title)); cheatBase:Destroy(); return end
    cheatBase.Parent = contentParent; cheatBase.LayoutOrder = getLayoutOrder(contentParent)
    local elementContent = cheatBase:FindFirstChild("Content") and cheatBase.Content:FindFirstChild("ElementContent")
    if not elementContent then warn("UILibrary.Section:Slider - Не найден ElementContent в cheatBase: " .. tostring(sett.Title)); cheatBase:Destroy(); return end
    local element = elementContent:FindFirstChild("Slider")
    if not element then warn("UILibrary.Section:Slider - Не найден Slider в ElementContent: " .. tostring(sett.Title)); cheatBase:Destroy(); return end
    local keyInputElement = element:FindFirstChild("KeyInput"); local dragElement = element:FindFirstChild("Drag")
    local dragFrameGradient = dragElement and dragElement:FindFirstChild("Frame") and dragElement.Frame:FindFirstChild("UIGradient")
    local keyInputText = keyInputElement and keyInputElement:FindFirstChild("Text")
    if not keyInputElement or not dragElement or not dragFrameGradient or not keyInputText then warn("UILibrary.Section:Slider - Неполная структура элемента Slider: " .. tostring(sett.Title)); cheatBase:Destroy(); return end
    sett.Min = sett.Min or 0; sett.Max = sett.Max or 10
    if sett.Min >= sett.Max then warn(string.format("UILibrary.Section:Slider - Min (%s) >= Max (%s). Max = Min + 10.", sett.Min, sett.Max, sett.Title)); sett.Max = sett.Min + 10 end
    local sliderValue = sett.Default or sett.Min; local scaleValue = 0
    functions.getData = function() return sett end
    functions.setValue = function(v, scale)
        local numV, numScale = tonumber(v), tonumber(scale)
        if numV == nil or numScale == nil then warn(string.format("UILibrary.Section:Slider.setValue - Некорректные значения v (%s) или scale (%s)", v, scale)); return end
        numV = math.clamp(numV, sett.Min, sett.Max); numScale = math.clamp(numScale, 0, 1)
        sliderValue = numV; scaleValue = numScale
        keyInputText.Text = string.format("%.1f", sliderValue)
        TweenService:Create(dragFrameGradient, TI, {Offset = Vector2.new(scaleValue, 0)}):Play()
        callback(sliderValue)
    end
    functions.getValue = function() return sliderValue end
    keyInputText.Focused:Connect(function() TweenService:Create(keyInputElement, TI, {BackgroundColor3 = Color3.fromRGB(17, 17, 17)}):Play() end)
    keyInputText.FocusLost:Connect(function()
        TweenService:Create(keyInputElement, TI, {BackgroundColor3 = Color3.fromRGB(25, 25, 25)}):Play()
        local numVal = tonumber(keyInputText.Text)
        if numVal then local clampedVal = math.clamp(numVal, sett.Min, sett.Max); local scale = 0
            if (sett.Max - sett.Min) > 0 then scale = math.clamp((clampedVal - sett.Min) / (sett.Max - sett.Min), 0, 1) end
            functions.setValue(clampedVal, scale)
        else keyInputText.Text = string.format("%.1f", sliderValue) end
    end)
    local holding = false; local activeTouchId = nil; local dragRenderStepConnection
    dragRenderStepConnection = RunService.RenderStepped:Connect(function()
        if holding then local success, err = pcall(function()
            if not dragElement or not dragElement.Parent then if dragRenderStepConnection then dragRenderStepConnection:Disconnect() end return end
            local pointerX; if activeTouchId then local foundTouch = false
                for _, touch_obj in ipairs(UserInputService:GetTouches()) do if touch_obj.TouchId == activeTouchId then pointerX = touch_obj.Position.X; foundTouch = true; break end end
                if not foundTouch then holding = false; activeTouchId = nil; return end
            else pointerX = UserInputService:GetMouseLocation().X end
            local sliderPos = dragElement.AbsolutePosition.X; local sliderWidth = dragElement.AbsoluteSize.X
            if sliderWidth <= 0 then return end
            local maxPos = math.clamp((pointerX - sliderPos) / sliderWidth, 0, 1); local val = sett.Min + (sett.Max - sett.Min) * maxPos
            functions.setValue(val, maxPos)
        end)
        if not success then warn("Ошибка в RenderStepped для слайдера:", err); holding = false; activeTouchId = nil; if dragRenderStepConnection then dragRenderStepConnection:Disconnect() end end
        end
    end)
    dragElement.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then holding = true
        elseif input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin then if activeTouchId then return end; activeTouchId = input.TouchId; holding = true end
    end)
    dragElement.InputEnded:Connect(function(input, gp)
        if gp then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then holding = false
        elseif input.UserInputType == Enum.UserInputType.Touch and input.TouchId == activeTouchId then holding = false; activeTouchId = nil end
    end)
    local initialValue = sett.Default or sett.Min; local initialScale = 0
    if (sett.Max - sett.Min) > 0 then initialScale = math.clamp((initialValue - sett.Min) / (sett.Max - sett.Min), 0, 1) end
    functions.setValue(initialValue, initialScale)
    local meta = setmetatable({element = element, UI = cheatBase, Destroy = function(self) if dragRenderStepConnection then dragRenderStepConnection:Disconnect(); dragRenderStepConnection = nil end if self.UI and self.UI.Parent then self.UI:Destroy() end end}, functions)
    if self.oldSelf and self.oldSelf.oldSelf and self.oldSelf.oldSelf.UI and self.oldSelf.categoryUI then
        local categoryName = self.oldSelf.categoryUI.Name; local sectionName = self.oldSelf.SectionName; local sectionTitle = self.Section.Name; local cheatTitle = sett.Title
        if self.oldSelf.oldSelf.UI[categoryName] and self.oldSelf.oldSelf.UI[categoryName][sectionName] and self.oldSelf.oldSelf.UI[categoryName][sectionName][sectionTitle] then
            self.oldSelf.oldSelf.UI[categoryName][sectionName][sectionTitle][cheatTitle] = meta
        else warn("Не удалось сохранить метатаблицу для слайдера: ", cheatTitle) end
    end
    return meta
end

function UILibrary.Section:Dropdown(sett, callback)
    local functions = {}
    functions.__index = functions

    local cheatBase = generateCheatBase("Dropdown", sett)
    cheatBase.Parent = self.Section.Border.Content
    cheatBase.LayoutOrder = getLayoutOrder(self.Section.Border.Content)

    local element = cheatBase.Content.ElementContent.Dropdown
    local mainHolderInteractive = element.MainHolder -- Это ImageButton

    local slot = element.Slot:Clone()
    element.Slot:Destroy()

    local bottom = element.Bottom:Clone()
    element.Bottom:Destroy()

    local top = element.Top:Clone()
    element.Top:Destroy()

    local conns = {}
    local menuOpen = false

    local options = sett.Options ~= nil and sett.Options or {}
    -- local selectedOptions = {} -- Не используется

    local optionConnections = {}

    functions.refreshUI = function()
        local String = ""

        for i_optName, v_isSet in pairs(options) do
            local ui_opt = element.OptionHolder.ContentHolder.Content:FindFirstChild(i_optName)
            if ui_opt then
                if v_isSet then
                    TweenService:Create(
                        ui_opt.Select,
                        TI,
                        {
                            ImageTransparency = 0
                        }
                    ):Play()

                    if String == "" then
                        String = i_optName
                    else
                        String = String .. ", " .. i_optName
                    end
                else
                    TweenService:Create(
                        ui_opt.Select,
                        TI,
                        {
                            ImageTransparency = 1
                        }
                    ):Play()
                end
            end
        end

        if String == "" then
            String = "None"
        end

        element.MainHolder.Content.Text.Text = String
    end

    functions.setValue = function(option, value, isDefault)
        if options[option] ~= nil then
            if element.OptionHolder.ContentHolder.Content:FindFirstChild(option) then
                if sett.Multi == true then
                    options[option] = value
                    functions.refreshUI()
                else
                    if value == true then
                        for i_opt, v_val in pairs(options) do
                            options[i_opt] = false
                        end
                        -- if isDefault == nil then -- Убрано, чтобы не вызывать рекурсию/двойное открытие
                        -- functions.openMenu()
                        -- end
                        options[option] = true
                        functions.refreshUI()
                    end
                end
                callback(options)
            end
        end
    end

    local function updateDropdown()
        for i_child, v_child in pairs(element.OptionHolder.ContentHolder.Content:GetChildren()) do
            if v_child:IsA("GuiObject") then
                v_child:Destroy()
            end
        end

        for i_conn, v_conn in pairs(optionConnections) do
            v_conn:Disconnect()
        end
        optionConnections = {}

        local counter = 0
        local totalCounter = 0

        for i_loop, v_loop in pairs(options) do
            totalCounter = totalCounter + 1
        end

        for v_name, i_val in pairs(options) do
            local Option

            counter = counter + 1

            if counter == totalCounter then
                Option = bottom:Clone()
            elseif counter ~= 1 then
                Option = slot:Clone()
            else
                Option = top:Clone()
            end

            Option.Name = v_name
            Option.Parent = element.OptionHolder.ContentHolder.Content
            Option.LayoutOrder = counter
            Option.Size = UDim2.fromScale(1, (totalCounter > 0 and (1 / totalCounter)) or 1)

            Option.Current.Text = v_name

            table.insert(optionConnections, Option.InputBegan:Connect(function(input, gp)
                if gp then return end
                if input.UserInputType == Enum.UserInputType.MouseButton1 or (input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin) then
                    functions.setValue(v_name, not options[v_name])
                elseif input.UserInputType == Enum.UserInputType.MouseMovement then
                    TweenService:Create(Option, TI, { ImageColor3 = Color3.fromRGB(20, 20, 20) }):Play()
                end
            end))

            table.insert(optionConnections, Option.InputEnded:Connect(function(input, gp)
                if input.UserInputType == Enum.UserInputType.MouseMovement then
                    TweenService:Create(Option, TI, { ImageColor3 = Color3.fromRGB(25, 25, 25) }):Play()
                end
            end))
        end
    end

    updateDropdown()

    functions.updateDropdown = function(new)
        options = new
        updateDropdown()
        functions.refreshUI()
    end

    functions.openMenu = function()
        local totalCounter = 0
        for i_loop, v_loop in pairs(options) do totalCounter = totalCounter + 1 end
        if totalCounter == 0 then return end

        menuOpen = not menuOpen

        if menuOpen then
            TweenService:Create(element.MainHolder.Content.Icon.Holder, TI, {Rotation = 180}):Play()
            TweenService:Create(element.OptionHolder, TI, {Size = UDim2.fromScale(1, math.clamp(totalCounter, 0, 5) * .7)}):Play() -- Ограничим высоту для очень длинных списков
            local n = 15 + (10 * math.clamp(totalCounter, 0, 3))
            TweenService:Create(element.OptionHolder.Cover.DropShadow, TI, {ImageTransparency = 0.5, Size = UDim2.new(1, n, 1, n)}):Play()
            element.OptionHolder.Visible = true
            task.delay(.4, function()
                if menuOpen and element.OptionHolder and element.OptionHolder.Cover then
                    TweenService:Create(element.OptionHolder.Cover, TI, {BackgroundTransparency = 1}):Play()
                end
            end)
        else
            TweenService:Create(element.MainHolder.Content.Icon.Holder, TI, {Rotation = 0}):Play()
            TweenService:Create(element.OptionHolder, TI, {Size = UDim2.fromScale(1, 0)}):Play()
            TweenService:Create(element.OptionHolder.Cover.DropShadow, TI, {ImageTransparency = 1, Size = UDim2.new(1, 0, 1, 0)}):Play()
            TweenService:Create(element.OptionHolder.Cover, TweenInfo.new(.2, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
            task.delay(.4, function()
                if not menuOpen and element.OptionHolder then element.OptionHolder.Visible = false end
            end)
        end
    end

    functions.getValue = function()
        return options
    end

    if mainHolderInteractive.InputBegan and mainHolderInteractive.InputEnded then
        table.insert(conns, mainHolderInteractive.InputBegan:Connect(function(input, gp) if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                if element.MainHolder.Content.Icon.Holder.Icon then
                    TweenService:Create(element.MainHolder.Content.Icon.Holder.Icon, TI, {Position = UDim2.fromScale(0, .2), ImageColor3 = Color3.fromRGB(50, 50, 50)}):Play()
                end
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 or (input.UserInputType == Enum.UserInputType.Touch and input.UserInputState == Enum.UserInputState.Begin) then
                functions.openMenu()
            end
        end))

        table.insert(conns, mainHolderInteractive.InputEnded:Connect(function(input, gp) if gp then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                 if element.MainHolder.Content.Icon.Holder.Icon then
                    TweenService:Create(element.MainHolder.Content.Icon.Holder.Icon, TI, {Position = UDim2.fromScale(0, 0), ImageColor3 = Color3.fromRGB(181, 181, 181)}):Play()
                 end
            end
        end))
    else
        warn("Dropdown: InputBegan или InputEnded не найдены для MainHolder.")
    end


    if sett.Default then
        if sett.Multi then
            for def_opt, def_val in pairs(sett.Default) do
                 if options[def_opt] ~= nil then options[def_opt] = def_val end
            end
            functions.refreshUI()
        else
            functions.setValue(sett.Default, true, true)
        end
    end


    local meta =
        setmetatable(
        {
            element = element,
            UI = cheatBase
        },
        functions
    )

    self.oldSelf.oldSelf.oldSelf.UI[self.oldSelf.oldSelf.categoryUI.Name][self.oldSelf.SectionName][
            self.Section.Name
        ][sett.Title] = meta

    return meta
end

function UILibrary.Section:Label(sett)
    local labelElement = objectGenerator.new("LabelElement")

    local titleLabel = labelElement:FindFirstChild("Title")
    local descLabel = labelElement:FindFirstChild("Description")

    if not titleLabel then
        warn("UILibrary: Не удалось найти 'Title' в шаблоне LabelElement.")
        labelElement:Destroy()
        return nil
    end

    titleLabel.Text = sett.Title or sett.Text or "Label Text"

    if descLabel then
        if sett.Description and sett.Description ~= "" then
            descLabel.Text = sett.Description
            descLabel.Visible = true
        else
            descLabel.Visible = false
            descLabel.Size = UDim2.new(1, 0, 0, 0)
        end
    elseif sett.Description and sett.Description ~= "" then
        warn("UILibrary: Не удалось найти 'Description' в шаблоне LabelElement, но описание было предоставлено")
    end

    labelElement.LayoutOrder = getLayoutOrder(self.Section.Border.Content)
    labelElement.Parent = self.Section.Border.Content

    local functions = {}
    functions.__index = functions

    function functions:SetTitle(newTitle)
        if titleLabel then titleLabel.Text = newTitle end
    end

    function functions:SetDescription(newDescription)
        if descLabel then
             if newDescription and newDescription ~= "" then
                descLabel.Text = newDescription
                descLabel.Visible = true
             else
                 descLabel.Visible = false
                 descLabel.Size = UDim2.new(1, 0, 0, 0)
             end
        end
    end

    local meta = setmetatable({
        UI = labelElement
    }, functions)
    return meta
end

return UILibrary
